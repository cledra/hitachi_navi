/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201608040617.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: This interface offers functions that implement the routing functionality of a
 *   navigation system
 */
#ifndef V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_ROUTING_HPP_
#define V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_ROUTING_HPP_


#include <v4/org/genivi/navigation/NavigationTypes.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>
#include <unordered_map>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v4 {
namespace org {
namespace genivi {
namespace navigation {
namespace navigationcore {

class Routing {
public:
    virtual ~Routing() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    
    struct CalculationStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            CALCULATION_OK = 304,
            NO_POSITION = 305
        };
        
        CalculationStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        CalculationStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        CalculationStatus &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::CALCULATION_OK):
                case static_cast<int32_t>(Literal::NO_POSITION):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const CalculationStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const CalculationStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const CalculationStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const CalculationStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const CalculationStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const CalculationStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct CalculationError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            UNMATCHED_POSITION = 306,
            UNREACHABLE_DESTINATION = 307,
            UNFULFILLED_PREFERENCE_MODE = 308
        };
        
        CalculationError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        CalculationError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        CalculationError &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::UNMATCHED_POSITION):
                case static_cast<int32_t>(Literal::UNREACHABLE_DESTINATION):
                case static_cast<int32_t>(Literal::UNFULFILLED_PREFERENCE_MODE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const CalculationError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const CalculationError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const CalculationError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const CalculationError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const CalculationError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const CalculationError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct CostModel : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            FASTEST = 352,
            SHORTEST = 353,
            ECOLOGICAL = 354,
            SCENIC = 355,
            EASY = 356,
            OFF_ROAD = 357,
            BALANCED = 358,
            CHEAPEST = 359
        };
        
        CostModel() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        CostModel(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        CostModel &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::FASTEST):
                case static_cast<int32_t>(Literal::SHORTEST):
                case static_cast<int32_t>(Literal::ECOLOGICAL):
                case static_cast<int32_t>(Literal::SCENIC):
                case static_cast<int32_t>(Literal::EASY):
                case static_cast<int32_t>(Literal::OFF_ROAD):
                case static_cast<int32_t>(Literal::BALANCED):
                case static_cast<int32_t>(Literal::CHEAPEST):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const CostModel &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const CostModel &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const CostModel &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const CostModel &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const CostModel &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const CostModel &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct RoutePreferenceSource : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            FERRY = 368,
            TOLL_ROADS = 369,
            TUNNELS = 370,
            HIGHWAYS_MOTORWAYS = 371,
            VEHICLE_SIZE_LIMIT = 372,
            CRIME_AREAS = 373
        };
        
        RoutePreferenceSource() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        RoutePreferenceSource(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        RoutePreferenceSource &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::FERRY):
                case static_cast<int32_t>(Literal::TOLL_ROADS):
                case static_cast<int32_t>(Literal::TUNNELS):
                case static_cast<int32_t>(Literal::HIGHWAYS_MOTORWAYS):
                case static_cast<int32_t>(Literal::VEHICLE_SIZE_LIMIT):
                case static_cast<int32_t>(Literal::CRIME_AREAS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const RoutePreferenceSource &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const RoutePreferenceSource &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const RoutePreferenceSource &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const RoutePreferenceSource &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const RoutePreferenceSource &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const RoutePreferenceSource &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct TransportationMeans : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            BY_CAR = 384,
            ON_FOOT = 385,
            LONG_RANGE_TRAINS = 386,
            PUBLIC_TRANSPORTATION = 387,
            BY_BICYCLE = 388,
            BY_TRUCK = 389
        };
        
        TransportationMeans() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        TransportationMeans(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        TransportationMeans &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::BY_CAR):
                case static_cast<int32_t>(Literal::ON_FOOT):
                case static_cast<int32_t>(Literal::LONG_RANGE_TRAINS):
                case static_cast<int32_t>(Literal::PUBLIC_TRANSPORTATION):
                case static_cast<int32_t>(Literal::BY_BICYCLE):
                case static_cast<int32_t>(Literal::BY_TRUCK):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TransportationMeans &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TransportationMeans &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TransportationMeans &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TransportationMeans &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TransportationMeans &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TransportationMeans &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct Schedule : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            ARRIVAL_TIME = 394,
            ARRIVAL_DATE = 395,
            DEPARTURE_TIME = 396,
            DEPARTURE_DATE = 397
        };
        
        Schedule() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        Schedule(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        Schedule &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::ARRIVAL_TIME):
                case static_cast<int32_t>(Literal::ARRIVAL_DATE):
                case static_cast<int32_t>(Literal::DEPARTURE_TIME):
                case static_cast<int32_t>(Literal::DEPARTURE_DATE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Schedule &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Schedule &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Schedule &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Schedule &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Schedule &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Schedule &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct PreferenceMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            PROHIBIT = 400,
            AVOID = 401,
            USE = 402,
            PREFER = 403,
            IGNORE = 404
        };
        
        PreferenceMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        PreferenceMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        PreferenceMode &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::PROHIBIT):
                case static_cast<int32_t>(Literal::AVOID):
                case static_cast<int32_t>(Literal::USE):
                case static_cast<int32_t>(Literal::PREFER):
                case static_cast<int32_t>(Literal::IGNORE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PreferenceMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PreferenceMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PreferenceMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PreferenceMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PreferenceMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PreferenceMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ConditionPreferenceSource : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            TRAFFIC_REALTIME = 512
        };
        
        ConditionPreferenceSource() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        ConditionPreferenceSource(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        ConditionPreferenceSource &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::TRAFFIC_REALTIME):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ConditionPreferenceSource &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ConditionPreferenceSource &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ConditionPreferenceSource &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ConditionPreferenceSource &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ConditionPreferenceSource &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ConditionPreferenceSource &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef std::unordered_map<::v4::org::genivi::navigation::navigationcore::Routing::PreferenceMode, ::v4::org::genivi::navigation::navigationcore::Routing::RoutePreferenceSource, CommonAPI::EnumHasher<::v4::org::genivi::navigation::navigationcore::Routing::PreferenceMode>> UnfullfilledRoutePreference;
    struct RoutePreference : CommonAPI::Struct<PreferenceMode, RoutePreferenceSource> {
    	
    	RoutePreference() {
    	}
    	RoutePreference(const PreferenceMode &_mode, const RoutePreferenceSource &_source)
    	{
    		std::get<0>(values_) = _mode;
    		std::get<1>(values_) = _source;
    	}
    	inline const PreferenceMode &getMode() const { return std::get<0>(values_); }
    	inline void setMode(const PreferenceMode &_value) { std::get<0>(values_) = _value; }
    	inline const RoutePreferenceSource &getSource() const { return std::get<1>(values_); }
    	inline void setSource(const RoutePreferenceSource &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const RoutePreference& _other) const {
                return (getMode() == _other.getMode() && getSource() == _other.getSource());
        }
    	inline bool operator!=(const RoutePreference &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    struct ConditionPreference : CommonAPI::Struct<PreferenceMode, ConditionPreferenceSource> {
    	
    	ConditionPreference() {
    	}
    	ConditionPreference(const PreferenceMode &_mode, const ConditionPreferenceSource &_source)
    	{
    		std::get<0>(values_) = _mode;
    		std::get<1>(values_) = _source;
    	}
    	inline const PreferenceMode &getMode() const { return std::get<0>(values_); }
    	inline void setMode(const PreferenceMode &_value) { std::get<0>(values_) = _value; }
    	inline const ConditionPreferenceSource &getSource() const { return std::get<1>(values_); }
    	inline void setSource(const ConditionPreferenceSource &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const ConditionPreference& _other) const {
                return (getMode() == _other.getMode() && getSource() == _other.getSource());
        }
    	inline bool operator!=(const ConditionPreference &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::unordered_map<::v4::org::genivi::navigation::navigationcore::Routing::Schedule, uint32_t, CommonAPI::EnumHasher<::v4::org::genivi::navigation::navigationcore::Routing::Schedule>> RouteSchedule;
    
    struct TimeStampedEnum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            TIMESTAMP = 16
        };
        
        TimeStampedEnum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        TimeStampedEnum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        TimeStampedEnum &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::TIMESTAMP):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const TimeStampedEnum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const TimeStampedEnum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const TimeStampedEnum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const TimeStampedEnum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const TimeStampedEnum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const TimeStampedEnum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GeoLocalizedEnum : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            TIMESTAMP = 16,
            LATITUDE = 160,
            LONGITUDE = 161,
            ALTITUDE = 162
        };
        
        GeoLocalizedEnum() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GeoLocalizedEnum(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GeoLocalizedEnum &operator=(const TimeStampedEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
        GeoLocalizedEnum &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::TIMESTAMP):
                case static_cast<int32_t>(Literal::LATITUDE):
                case static_cast<int32_t>(Literal::LONGITUDE):
                case static_cast<int32_t>(Literal::ALTITUDE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GeoLocalizedEnum &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GeoLocalizedEnum &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GeoLocalizedEnum &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GeoLocalizedEnum &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GeoLocalizedEnum &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GeoLocalizedEnum &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct WayPointType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            HARD_POINT = 290,
            SOFT_POINT = 291
        };
        
        WayPointType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::HARD_POINT)) {}
        WayPointType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::HARD_POINT):
                case static_cast<int32_t>(Literal::SOFT_POINT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const WayPointType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const WayPointType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const WayPointType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const WayPointType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const WayPointType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const WayPointType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct IntermediatePoint : CommonAPI::Struct<double, double, WayPointType> {
    	
    	IntermediatePoint() {
    	}
    	IntermediatePoint(const double &_latitude, const double &_longitude, const WayPointType &_type)
    	{
    		std::get<0>(values_) = _latitude;
    		std::get<1>(values_) = _longitude;
    		std::get<2>(values_) = _type;
    	}
    	/**
    	 * description: latitude of the current position (according WGS84). Range [-90:+90]. Example:
    	 *   48.053250 .
    	 */
    	inline const double &getLatitude() const { return std::get<0>(values_); }
    	inline void setLatitude(const double &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: longitude of the current position (according WGS84). Range [-180:+180].
    	 *   Example: 8.324500 .
    	 */
    	inline const double &getLongitude() const { return std::get<1>(values_); }
    	inline void setLongitude(const double &_value) { std::get<1>(values_) = _value; }
    	inline const WayPointType &getType() const { return std::get<2>(values_); }
    	inline void setType(const WayPointType &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const IntermediatePoint& _other) const {
                return (getLatitude() == _other.getLatitude() && getLongitude() == _other.getLongitude() && getType() == _other.getType());
        }
    	inline bool operator!=(const IntermediatePoint &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct RouteOverviewType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            ARRIVAL_TIME = 394,
            ARRIVAL_DATE = 395,
            DEPARTURE_TIME = 396,
            DEPARTURE_DATE = 397,
            TOTAL_TIME = 398,
            TOTAL_DISTANCE = 399
        };
        
        RouteOverviewType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        RouteOverviewType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        RouteOverviewType &operator=(const Schedule::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
        RouteOverviewType &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::ARRIVAL_TIME):
                case static_cast<int32_t>(Literal::ARRIVAL_DATE):
                case static_cast<int32_t>(Literal::DEPARTURE_TIME):
                case static_cast<int32_t>(Literal::DEPARTURE_DATE):
                case static_cast<int32_t>(Literal::TOTAL_TIME):
                case static_cast<int32_t>(Literal::TOTAL_DISTANCE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const RouteOverviewType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const RouteOverviewType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const RouteOverviewType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const RouteOverviewType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const RouteOverviewType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const RouteOverviewType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef CommonAPI::Variant<uint32_t>  RouteOverviewItem;
    typedef std::unordered_map<::v4::org::genivi::navigation::navigationcore::Routing::RouteOverviewType, ::v4::org::genivi::navigation::navigationcore::Routing::RouteOverviewItem, CommonAPI::EnumHasher<::v4::org::genivi::navigation::navigationcore::Routing::RouteOverviewType>> RouteOverview;
    
    struct WaypointElementType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            LATITUDE = 160,
            LONGITUDE = 161,
            ALTITUDE = 162,
            LOCATION_INPUT = 17,
            WAYPOINT_TYPE = 289
        };
        
        WaypointElementType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::LATITUDE)) {}
        WaypointElementType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::LATITUDE):
                case static_cast<int32_t>(Literal::LONGITUDE):
                case static_cast<int32_t>(Literal::ALTITUDE):
                case static_cast<int32_t>(Literal::LOCATION_INPUT):
                case static_cast<int32_t>(Literal::WAYPOINT_TYPE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const WaypointElementType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const WaypointElementType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const WaypointElementType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const WaypointElementType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const WaypointElementType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const WaypointElementType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef CommonAPI::Variant<double, WayPointType, std::vector<uint8_t>>  WayPointItem;
    typedef std::unordered_map<::v4::org::genivi::navigation::navigationcore::Routing::WaypointElementType, ::v4::org::genivi::navigation::navigationcore::Routing::WayPointItem, CommonAPI::EnumHasher<::v4::org::genivi::navigation::navigationcore::Routing::WaypointElementType>> WayPoint;
    
    struct RouteSegmentType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            LINK_ID = 320,
            START_LATITUDE = 321,
            END_LATITUDE = 322,
            START_LONGITUDE = 323,
            END_LONGITUDE = 324,
            START_ALTITUDE = 325,
            END_ALTITUDE = 326,
            ROAD_NAME = 327,
            DISTANCE = 328,
            TIME = 329,
            MANEUVER = 330,
            INSTRUCTION = 331,
            BORDER_CROSSING = 332,
            ADDITIONAL_INFORMATION = 333,
            ROAD_NUMBER = 334,
            START_OFFSET = 335,
            INTERMEDIATE_POINTS = 288,
            HIGHWAY_EXIT = 116,
            SPEED = 164
        };
        
        RouteSegmentType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        RouteSegmentType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        RouteSegmentType &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::LINK_ID):
                case static_cast<int32_t>(Literal::START_LATITUDE):
                case static_cast<int32_t>(Literal::END_LATITUDE):
                case static_cast<int32_t>(Literal::START_LONGITUDE):
                case static_cast<int32_t>(Literal::END_LONGITUDE):
                case static_cast<int32_t>(Literal::START_ALTITUDE):
                case static_cast<int32_t>(Literal::END_ALTITUDE):
                case static_cast<int32_t>(Literal::ROAD_NAME):
                case static_cast<int32_t>(Literal::DISTANCE):
                case static_cast<int32_t>(Literal::TIME):
                case static_cast<int32_t>(Literal::MANEUVER):
                case static_cast<int32_t>(Literal::INSTRUCTION):
                case static_cast<int32_t>(Literal::BORDER_CROSSING):
                case static_cast<int32_t>(Literal::ADDITIONAL_INFORMATION):
                case static_cast<int32_t>(Literal::ROAD_NUMBER):
                case static_cast<int32_t>(Literal::START_OFFSET):
                case static_cast<int32_t>(Literal::INTERMEDIATE_POINTS):
                case static_cast<int32_t>(Literal::HIGHWAY_EXIT):
                case static_cast<int32_t>(Literal::SPEED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const RouteSegmentType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const RouteSegmentType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const RouteSegmentType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const RouteSegmentType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const RouteSegmentType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const RouteSegmentType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    typedef CommonAPI::Variant<double, std::vector<IntermediatePoint>, std::string, std::vector<uint8_t>, int32_t, int16_t, uint32_t>  RouteSegmentItem;
    typedef std::unordered_map<::v4::org::genivi::navigation::navigationcore::Routing::RouteSegmentType, ::v4::org::genivi::navigation::navigationcore::Routing::RouteSegmentItem, CommonAPI::EnumHasher<::v4::org::genivi::navigation::navigationcore::Routing::RouteSegmentType>> RouteSegment;
    /**
     * description: struct generated for DBus argument SetBlockedRouteStretches_blockParameters
     */
    struct BlockedRouteElement : CommonAPI::Struct<uint32_t, uint32_t> {
    	
    	BlockedRouteElement() {
    	}
    	BlockedRouteElement(const uint32_t &_offset, const uint32_t &_length)
    	{
    		std::get<0>(values_) = _offset;
    		std::get<1>(values_) = _length;
    	}
    	inline const uint32_t &getOffset() const { return std::get<0>(values_); }
    	inline void setOffset(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	inline const uint32_t &getLength() const { return std::get<1>(values_); }
    	inline void setLength(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const BlockedRouteElement& _other) const {
                return (getOffset() == _other.getOffset() && getLength() == _other.getLength());
        }
    	inline bool operator!=(const BlockedRouteElement &_other) const {
    		return !((*this) == _other);
    	}
    
    };
};

const char* Routing::getInterface() {
    return ("org.genivi.navigation.navigationcore.Routing");
}

CommonAPI::Version Routing::getInterfaceVersion() {
    return CommonAPI::Version(4, 0);
}

/**
 * description: struct generated for DBus argument SetBlockedRouteStretches_blockParameters
 */

} // namespace navigationcore
} // namespace navigation
} // namespace genivi
} // namespace org
} // namespace v4

namespace CommonAPI {
}


// Compatibility
namespace v4_0 = v4;

#endif // V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_ROUTING_HPP_
