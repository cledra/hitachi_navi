/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201608040617.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v4/org/genivi/navigation/navigationcore/RoutingStubDefault.hpp>
#include <assert.h>

namespace v4 {
namespace org {
namespace genivi {
namespace navigation {
namespace navigationcore {

RoutingStubDefault::RoutingStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(Routing::getInterfaceVersion()) {
}

const CommonAPI::Version& RoutingStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return interfaceVersion_;
}

RoutingStubRemoteEvent* RoutingStubDefault::initStubAdapter(const std::shared_ptr<RoutingStubAdapter> &_adapter) {
    CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}


/**
 * description: This method returns the API version implemented by the server application
 */
void RoutingStubDefault::getVersion(const std::shared_ptr<CommonAPI::ClientId> _client, getVersionReply_t _reply) {
    (void)_client;
    ::v4::org::genivi::CommonTypes::Version version = {};
    _reply(version);
}

/**
 * description: This method creates a route
 */
void RoutingStubDefault::createRoute(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, createRouteReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    ::v4::org::genivi::navigation::NavigationTypes::Handle routeHandle = 0ul;
    _reply(routeHandle);
}

/**
 * description: This method deletes a route and its associated resources
 */
void RoutingStubDefault::deleteRoute(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, deleteRouteReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeHandle;
    _reply();
}

/**
 * description: This method sets the cost model
 */
void RoutingStubDefault::setCostModel(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, Routing::CostModel _costModel, setCostModelReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeHandle;
    (void) _costModel;
    _reply();
}

/**
 * description: This method retrieves the selected cost model
 */
void RoutingStubDefault::getCostModel(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, getCostModelReply_t _reply) {
    (void)_client;
    (void) _routeHandle;
    Routing::CostModel costModel = Routing::CostModel::FASTEST;
    if (!costModel.validate()) {
        return;
    }
    _reply(costModel);
}

/**
 * description: This method retrieves a list of supported cost models
 */
void RoutingStubDefault::getSupportedCostModels(const std::shared_ptr<CommonAPI::ClientId> _client, getSupportedCostModelsReply_t _reply) {
    (void)_client;
    std::vector<Routing::CostModel> costModelsList = {};
    _reply(costModelsList);
}

/**
 * description: This method sets a list of route preferences
 */
void RoutingStubDefault::setRoutePreferences(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, std::string _countryCode, std::vector<Routing::RoutePreference> _roadPreferenceList, std::vector<Routing::ConditionPreference> _conditionPreferenceList, setRoutePreferencesReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeHandle;
    (void) _countryCode;
    (void) _roadPreferenceList;
    (void) _conditionPreferenceList;
    _reply();
}

/**
 * description: This method retrieves a list of selected route preferences
 */
void RoutingStubDefault::getRoutePreferences(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, std::string _countryCode, getRoutePreferencesReply_t _reply) {
    (void)_client;
    (void) _routeHandle;
    (void) _countryCode;
    std::vector<Routing::RoutePreference> roadPreferenceList = {};
    std::vector<Routing::ConditionPreference> conditionPreferenceList = {};
    _reply(roadPreferenceList, conditionPreferenceList);
}

/**
 * description: This method retrieves a list of supported route preferences
 */
void RoutingStubDefault::getSupportedRoutePreferences(const std::shared_ptr<CommonAPI::ClientId> _client, getSupportedRoutePreferencesReply_t _reply) {
    (void)_client;
    std::vector<Routing::RoutePreference> routePreferencesList = {};
    std::vector<Routing::ConditionPreference> conditionPreferenceList = {};
    _reply(routePreferencesList, conditionPreferenceList);
}

/**
 * description: This method sets the time schedule for the route to be calculated
 */
void RoutingStubDefault::setRouteSchedule(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, Routing::RouteSchedule _routeSchedule, setRouteScheduleReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeHandle;
    (void) _routeSchedule;
    _reply();
}

/**
 * description: This method gets the time schedule for the route to be calculated
 */
void RoutingStubDefault::getRouteSchedule(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, std::vector<Routing::Schedule> _valuesToReturn, getRouteScheduleReply_t _reply) {
    (void)_client;
    (void) _routeHandle;
    (void) _valuesToReturn;
    Routing::RouteSchedule routeSchedule;
    _reply(routeSchedule);
}

/**
 * description: This method sets a list of means of transportation that must be considered when
 *   calculating a route
 */
void RoutingStubDefault::setTransportationMeans(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, std::vector<Routing::TransportationMeans> _transportationMeansList, setTransportationMeansReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeHandle;
    (void) _transportationMeansList;
    _reply();
}

/**
 * description: getTransportationMeans = This method retrieves the selected means of
 *   transportation
 */
void RoutingStubDefault::getTransportationMeans(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, getTransportationMeansReply_t _reply) {
    (void)_client;
    (void) _routeHandle;
    std::vector<Routing::TransportationMeans> transportationMeansList = {};
    _reply(transportationMeansList);
}

/**
 * description: getSupportedTransportationMeans = This method retrieves a list of supported
 *   means of transportation
 */
void RoutingStubDefault::getSupportedTransportationMeans(const std::shared_ptr<CommonAPI::ClientId> _client, getSupportedTransportationMeansReply_t _reply) {
    (void)_client;
    std::vector<Routing::TransportationMeans> transportationMeansList = {};
    _reply(transportationMeansList);
}

/**
 * description: setExcludedAreas = This method sets the areas to be excluded when calculating a
 *   route
 */
void RoutingStubDefault::setExcludedAreas(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon> _excludedAreas, setExcludedAreasReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeHandle;
    (void) _excludedAreas;
    _reply();
}

/**
 * description: getExcludedAreas = This method retrieves the areas to be excluded when
 *   calculating a route
 */
void RoutingStubDefault::getExcludedAreas(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, getExcludedAreasReply_t _reply) {
    (void)_client;
    (void) _routeHandle;
    std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon> excludedAreas = {};
    _reply(excludedAreas);
}

/**
 * description: setWaypoints = This method sets a list of waypoints
 */
void RoutingStubDefault::setWaypoints(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, bool _startFromCurrentPosition, std::vector<Routing::WayPoint> _waypointsList, setWaypointsReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeHandle;
    (void) _startFromCurrentPosition;
    (void) _waypointsList;
    _reply();
}

/**
 * description: getWaypoints = This method retrieves a list of waypoints
 */
void RoutingStubDefault::getWaypoints(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, getWaypointsReply_t _reply) {
    (void)_client;
    (void) _routeHandle;
    bool startFromCurrentPosition = false;
    std::vector<Routing::WayPoint> waypointsList = {};
    _reply(startFromCurrentPosition, waypointsList);
}

/**
 * description: calculateRoute = This method starts a route calculation
 */
void RoutingStubDefault::calculateRoute(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, calculateRouteReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeHandle;
    _reply();
}

/**
 * description: cancelRouteCalculation = This method cancels a route calculation
 */
void RoutingStubDefault::cancelRouteCalculation(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, cancelRouteCalculationReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeHandle;
    _reply();
}

/**
 * description: calculateRoutes = This method allows a client to calculate alternative routes
 *   that differs from a list of already calculated routes
 */
void RoutingStubDefault::calculateRoutes(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> _calculatedRoutesList, calculateRoutesReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _calculatedRoutesList;
    std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> alternativeRoutesList = {};
    _reply(alternativeRoutesList);
}

/**
 * description: getRouteSegments = This method retrieves a list of segments for a given route
 *   starting from the one closest to the current position to the one closest to
 *   the destination
 */
void RoutingStubDefault::getRouteSegments(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, int16_t _detailLevel, std::vector<Routing::RouteSegmentType> _valuesToReturn, uint32_t _numberOfSegments, uint32_t _offset, getRouteSegmentsReply_t _reply) {
    (void)_client;
    (void) _routeHandle;
    (void) _detailLevel;
    (void) _valuesToReturn;
    (void) _numberOfSegments;
    (void) _offset;
    uint32_t totalNumberOfSegments = 0ul;
    std::vector<Routing::RouteSegment> routeSegments = {};
    _reply(totalNumberOfSegments, routeSegments);
}

/**
 * description: getRouteOverview = This method retrieves general information about a given route
 */
void RoutingStubDefault::getRouteOverview(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, std::vector<Routing::RouteOverviewType> _valuesToReturn, getRouteOverviewReply_t _reply) {
    (void)_client;
    (void) _routeHandle;
    (void) _valuesToReturn;
    Routing::RouteOverview routeOverview;
    _reply(routeOverview);
}

/**
 * description: getRouteBoundingBox = This method retrieves the bounding box containing a
 *   calculated route
 */
void RoutingStubDefault::getRouteBoundingBox(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, getRouteBoundingBoxReply_t _reply) {
    (void)_client;
    (void) _routeHandle;
    ::v4::org::genivi::navigation::NavigationTypes::Rectangle boundingBox = {};
    _reply(boundingBox);
}

/**
 * description: getAllRoutes = This method retrieves the handles of all created routes
 */
void RoutingStubDefault::getAllRoutes(const std::shared_ptr<CommonAPI::ClientId> _client, getAllRoutesReply_t _reply) {
    (void)_client;
    std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> routesList = {};
    _reply(routesList);
}

/**
 * description: setBlockedRouteStretches = This method sets blocked streches on a given route
 */
void RoutingStubDefault::setBlockedRouteStretches(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, std::vector<Routing::BlockedRouteElement> _blockParameters, setBlockedRouteStretchesReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeHandle;
    (void) _blockParameters;
    _reply();
}

/**
 * description: getBlockedRouteStretches = This method retrieves all blocked streches on a
 *   given route
 */
void RoutingStubDefault::getBlockedRouteStretches(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, getBlockedRouteStretchesReply_t _reply) {
    (void)_client;
    (void) _routeHandle;
    std::vector<Routing::BlockedRouteElement> blockParameters = {};
    _reply(blockParameters);
}


/**
 * description: routeDeleted = This signal is emitted to inform clients that the current route
 *   has been deleted
 */
void RoutingStubDefault::fireRouteDeletedEvent(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle) {
    assert((CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireRouteDeletedEvent(_routeHandle);
}
/**
 * description: routeCalculationCancelled = This signal informs a client that a route
 *   calculation was cancelled
 */
void RoutingStubDefault::fireRouteCalculationCancelledEvent(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle) {
    assert((CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireRouteCalculationCancelledEvent(_routeHandle);
}
/**
 * description: routeCalculationSuccessful = This signal informs a client that a route
 *   calculation was successful
 */
void RoutingStubDefault::fireRouteCalculationSuccessfulEvent(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const ::v4::org::genivi::navigation::navigationcore::Routing::UnfullfilledRoutePreference &_unfullfilledPreferences) {
    assert((CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireRouteCalculationSuccessfulEvent(_routeHandle, _unfullfilledPreferences);
}
/**
 * description: routeCalculationFailed = This signal informs a client that a route calculation
 *   failed
 */
void RoutingStubDefault::fireRouteCalculationFailedEvent(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_Handle, const ::v4::org::genivi::navigation::navigationcore::Routing::CalculationError &_errorCode, const ::v4::org::genivi::navigation::navigationcore::Routing::UnfullfilledRoutePreference &_unfullfilledPreferences) {
    if (!_errorCode.validate()) {
        return;
    }
    assert((CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireRouteCalculationFailedEvent(_Handle, _errorCode, _unfullfilledPreferences);
}
/**
 * description: routeCalculationProgressUpdate = This signal informs a client about a route
 *   calculation progress
 */
void RoutingStubDefault::fireRouteCalculationProgressUpdateEvent(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const ::v4::org::genivi::navigation::navigationcore::Routing::CalculationStatus &_status, const uint8_t &_percentage) {
    if (!_status.validate()) {
        return;
    }
    assert((CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireRouteCalculationProgressUpdateEvent(_routeHandle, _status, _percentage);
}
/**
 * description: alternativeRoutesAvailable = This signal is emitted when alternative routes
 *   have been computed in the background and are available for guidance.
 */
void RoutingStubDefault::fireAlternativeRoutesAvailableEvent(const std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_routeHandlesList) {
    assert((CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<RoutingStubAdapter, RoutingStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireAlternativeRoutesAvailableEvent(_routeHandlesList);
}


RoutingStubDefault::RemoteEventHandler::RemoteEventHandler(RoutingStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace navigationcore
} // namespace navigation
} // namespace genivi
} // namespace org
} // namespace v4
