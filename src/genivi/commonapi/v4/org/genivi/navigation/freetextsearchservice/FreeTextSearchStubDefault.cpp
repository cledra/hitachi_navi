/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201608040617.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v4/org/genivi/navigation/freetextsearchservice/FreeTextSearchStubDefault.hpp>
#include <assert.h>

namespace v4 {
namespace org {
namespace genivi {
namespace navigation {
namespace freetextsearchservice {

FreeTextSearchStubDefault::FreeTextSearchStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(FreeTextSearch::getInterfaceVersion()) {
}

const CommonAPI::Version& FreeTextSearchStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return interfaceVersion_;
}

FreeTextSearchStubRemoteEvent* FreeTextSearchStubDefault::initStubAdapter(const std::shared_ptr<FreeTextSearchStubAdapter> &_adapter) {
    CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}


/**
 * description: This method returns the API version implemented by the content access module.
 */
void FreeTextSearchStubDefault::getVersion(const std::shared_ptr<CommonAPI::ClientId> _client, FreeTextSearch::RequestId _requestId, getVersionReply_t _reply) {
    (void)_client;
    (void) _requestId;
    FreeTextSearch::RequestId responseId = 0;
    ::v4::org::genivi::CommonTypes::Version version = {};
    _reply(responseId, version);
}

/**
 * description: Perform a free text search.
        A single search request will trigger zero
 *   or more FtsResultXxx responses followed by an FtsDone response.
        Each
 *   response will contain 1 page of results.
        A next page of results can be
 *   retrieved with the FtsNextPage request.
        
        When you send a new
 *   request before receiving a done response on the previous request,
        then
 *   the previous request will be canceled.
        You will still get a done
 *   response on the previous request.
        This way each request gets a
 *   response.
 */
void FreeTextSearchStubDefault::ftsRequest(const std::shared_ptr<CommonAPI::ClientId> _client, FreeTextSearch::RequestId _requestId, FreeTextSearch::FtsString _inputString, ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D _searchLocation, FreeTextSearch::ShapeList _searchShapes, FreeTextSearch::PageSize _pageSize, FreeTextSearch::SearchOptions _searchOptions, FreeTextSearch::FtsString _searchConditions, FreeTextSearch::FuzzyLevel _fuzzyLevel, ftsRequestReply_t _reply) {
    (void)_client;
    (void) _requestId;
    (void) _inputString;
    (void) _searchLocation;
    (void) _searchShapes;
    (void) _pageSize;
    (void) _searchOptions;
    (void) _searchConditions;
    (void) _fuzzyLevel;
    FreeTextSearch::ftsRequestError error;
    FreeTextSearch::RequestId responseId = 0;
    ::v4::org::genivi::navigation::NavigationTypes::Handle freeTextSearchHandle = 0ul;
    _reply(error, responseId, freeTextSearchHandle);
}

/**
 * description: Get next result page for the last performed search.
        This request will
 *   trigger zero or more FtsResultXxx responses followed by an FtsDone response.
 
 *         If there is no search request done before or if a search request is
 *   still in progress
        hen the FtsDone response will return a
 *   EStatusNoSearchToContinue status.
 */
void FreeTextSearchStubDefault::ftsNextPage(const std::shared_ptr<CommonAPI::ClientId> _client, FreeTextSearch::RequestId _requestId, ::v4::org::genivi::navigation::NavigationTypes::Handle _freeTextSearchHandle, FreeTextSearch::SearchOptions _searchOptions, ftsNextPageReply_t _reply) {
    (void)_client;
    (void) _requestId;
    (void) _freeTextSearchHandle;
    (void) _searchOptions;
    FreeTextSearch::RequestId responseId = 0;
    _reply(responseId);
}

/**
 * description: Cancel an FTS session.
 */
void FreeTextSearchStubDefault::ftsCancel(const std::shared_ptr<CommonAPI::ClientId> _client, FreeTextSearch::RequestId _requestId, ::v4::org::genivi::navigation::NavigationTypes::Handle _freeTextSearchHandle, ftsCancelReply_t _reply) {
    (void)_client;
    (void) _requestId;
    (void) _freeTextSearchHandle;
    FreeTextSearch::RequestId responseId = 0;
    _reply(responseId);
}

/**
 * description: Release handle(s) if they are not used anymore.
 */
void FreeTextSearchStubDefault::deleteLocationHandles(const std::shared_ptr<CommonAPI::ClientId> _client, FreeTextSearch::RequestId _requestId, FreeTextSearch::LocationHandleList _locationHandleList, deleteLocationHandlesReply_t _reply) {
    (void)_client;
    (void) _requestId;
    (void) _locationHandleList;
    FreeTextSearch::RequestId responseId = 0;
    _reply(responseId);
}


/**
 * description: Response indicating that the search is done.
 */
void FreeTextSearchStubDefault::fireFtsDoneSelective(const ::v4::org::genivi::navigation::freetextsearchservice::FreeTextSearch::RequestId &_responseId, const ::v4::org::genivi::navigation::freetextsearchservice::FreeTextSearch::FtsStatus &_ftsStatus, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    if (!_ftsStatus.validate()) {
        return;
    }
    assert((CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock();
    if (stubAdapter)
        stubAdapter->sendFtsDoneSelective(_responseId, _ftsStatus, _receivers);
}
void FreeTextSearchStubDefault::onFtsDoneSelectiveSubscriptionChanged(const std::shared_ptr<CommonAPI::ClientId> _client, const CommonAPI::SelectiveBroadcastSubscriptionEvent _event) {
    (void)_client;
    (void)_event;
    // No operation in default
}
bool FreeTextSearchStubDefault::onFtsDoneSelectiveSubscriptionRequested(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    // Accept in default
    return true;
}
std::shared_ptr<CommonAPI::ClientIdList> const FreeTextSearchStubDefault::getSubscribersForFtsDoneSelective() {
    assert((CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        return(stubAdapter->getSubscribersForFtsDoneSelective());
    else
        return NULL;
}

/**
 * description: Response with address results.
 */
void FreeTextSearchStubDefault::fireFtsResultAddressesSelective(const ::v4::org::genivi::navigation::freetextsearchservice::FreeTextSearch::RequestId &_responseId, const ::v4::org::genivi::navigation::freetextsearchservice::FreeTextSearch::Addresses &_addresses, const bool &_moreAvailable, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    assert((CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock();
    if (stubAdapter)
        stubAdapter->sendFtsResultAddressesSelective(_responseId, _addresses, _moreAvailable, _receivers);
}
void FreeTextSearchStubDefault::onFtsResultAddressesSelectiveSubscriptionChanged(const std::shared_ptr<CommonAPI::ClientId> _client, const CommonAPI::SelectiveBroadcastSubscriptionEvent _event) {
    (void)_client;
    (void)_event;
    // No operation in default
}
bool FreeTextSearchStubDefault::onFtsResultAddressesSelectiveSubscriptionRequested(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    // Accept in default
    return true;
}
std::shared_ptr<CommonAPI::ClientIdList> const FreeTextSearchStubDefault::getSubscribersForFtsResultAddressesSelective() {
    assert((CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        return(stubAdapter->getSubscribersForFtsResultAddressesSelective());
    else
        return NULL;
}

/**
 * description: Response with POI results.
 */
void FreeTextSearchStubDefault::fireFtsResultPoisSelective(const ::v4::org::genivi::navigation::freetextsearchservice::FreeTextSearch::RequestId &_responseId, const ::v4::org::genivi::navigation::freetextsearchservice::FreeTextSearch::POIs &_pois, const bool &_moreAvailable, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    assert((CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock();
    if (stubAdapter)
        stubAdapter->sendFtsResultPoisSelective(_responseId, _pois, _moreAvailable, _receivers);
}
void FreeTextSearchStubDefault::onFtsResultPoisSelectiveSubscriptionChanged(const std::shared_ptr<CommonAPI::ClientId> _client, const CommonAPI::SelectiveBroadcastSubscriptionEvent _event) {
    (void)_client;
    (void)_event;
    // No operation in default
}
bool FreeTextSearchStubDefault::onFtsResultPoisSelectiveSubscriptionRequested(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    // Accept in default
    return true;
}
std::shared_ptr<CommonAPI::ClientIdList> const FreeTextSearchStubDefault::getSubscribersForFtsResultPoisSelective() {
    assert((CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        return(stubAdapter->getSubscribersForFtsResultPoisSelective());
    else
        return NULL;
}

/**
 * description: Response with POI category suggestions.
 */
void FreeTextSearchStubDefault::fireFtsResultPoiSuggestionsSelective(const ::v4::org::genivi::navigation::freetextsearchservice::FreeTextSearch::RequestId &_responseId, const ::v4::org::genivi::navigation::freetextsearchservice::FreeTextSearch::POICategories &_poiCategories, const std::shared_ptr<CommonAPI::ClientIdList> _receivers) {
    assert((CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock();
    if (stubAdapter)
        stubAdapter->sendFtsResultPoiSuggestionsSelective(_responseId, _poiCategories, _receivers);
}
void FreeTextSearchStubDefault::onFtsResultPoiSuggestionsSelectiveSubscriptionChanged(const std::shared_ptr<CommonAPI::ClientId> _client, const CommonAPI::SelectiveBroadcastSubscriptionEvent _event) {
    (void)_client;
    (void)_event;
    // No operation in default
}
bool FreeTextSearchStubDefault::onFtsResultPoiSuggestionsSelectiveSubscriptionRequested(const std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    // Accept in default
    return true;
}
std::shared_ptr<CommonAPI::ClientIdList> const FreeTextSearchStubDefault::getSubscribersForFtsResultPoiSuggestionsSelective() {
    assert((CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<FreeTextSearchStubAdapter, FreeTextSearchStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        return(stubAdapter->getSubscribersForFtsResultPoiSuggestionsSelective());
    else
        return NULL;
}



FreeTextSearchStubDefault::RemoteEventHandler::RemoteEventHandler(FreeTextSearchStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace freetextsearchservice
} // namespace navigation
} // namespace genivi
} // namespace org
} // namespace v4
