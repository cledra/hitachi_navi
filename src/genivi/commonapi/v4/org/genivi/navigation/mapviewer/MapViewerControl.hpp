/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201608040617.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: MapViewerControl = This interface offers functions to control the MapViewer
 */
#ifndef V4_ORG_GENIVI_NAVIGATION_MAPVIEWER_MAP_VIEWER_CONTROL_HPP_
#define V4_ORG_GENIVI_NAVIGATION_MAPVIEWER_MAP_VIEWER_CONTROL_HPP_


#include <v4/org/genivi/navigation/NavigationTypes.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>
#include <unordered_map>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v4 {
namespace org {
namespace genivi {
namespace navigation {
namespace mapviewer {

class MapViewerControl {
public:
    virtual ~MapViewerControl() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    
    struct MapViewType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            MAIN_MAP = 16,
            SPLIT_SCREEN = 17,
            GUIDING_MAP = 18
        };
        
        MapViewType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        MapViewType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        MapViewType &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::MAIN_MAP):
                case static_cast<int32_t>(Literal::SPLIT_SCREEN):
                case static_cast<int32_t>(Literal::GUIDING_MAP):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MapViewType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MapViewType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MapViewType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MapViewType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MapViewType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MapViewType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct MapScaleMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            AUTOMATIC = 272,
            MANUAL = 273,
            HYBRID = 274
        };
        
        MapScaleMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        MapScaleMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        MapScaleMode &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::AUTOMATIC):
                case static_cast<int32_t>(Literal::MANUAL):
                case static_cast<int32_t>(Literal::HYBRID):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MapScaleMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MapScaleMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MapScaleMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MapScaleMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MapScaleMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MapScaleMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct MapPerspective : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            PERSPECTIVE_2D = 32,
            PERSPECTIVE_3D = 33
        };
        
        MapPerspective() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        MapPerspective(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        MapPerspective &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::PERSPECTIVE_2D):
                case static_cast<int32_t>(Literal::PERSPECTIVE_3D):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MapPerspective &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MapPerspective &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MapPerspective &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MapPerspective &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MapPerspective &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MapPerspective &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct MapObject : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            BUILDINGS = 128,
            TERRAIN = 129,
            DET_POI = 65538,
            DET_TTI = 65539,
            DET_ONE_WAY_STREET_ARROW = 65540,
            DET_CITY_NAME = 65541,
            DET_ROAD_NAME = 65542,
            DET_MOTORWAY_EXIT_MARKER = 65543,
            DET_TRAFFIC_LIGHT = 65544,
            DET_TRAFFIC_LIGHTS_ALONG_ROUTE = 65545,
            DET_ROAD_ICON = 65546,
            DET_DTM = 65547,
            DET_LANDMARKS_3D = 65548,
            DET_FAVORITES = 65549,
            DET_ROUTE_BLOCKING = 65550,
            DET_ROAD = 65551,
            DET_POLYGON = 65552,
            DET_DESTINATION = 65553,
            DET_MANOEUVRE_MARKER = 65554,
            DET_LANE_GUIDANCE_MARKER = 65555,
            DET_ROUTE = 65556,
            DET_MANOEUVRE_ARROW = 65557,
            DET_TREKKING_TOUR = 65558,
            DET_TTI_EDGE_HIGHLIGHTING = 65559,
            DET_CITY_MARKER = 65560,
            DET_VEHICLE = 65561,
            DET_POLYGON_NAME = 65562,
            DET_OFF_ROAD_ROUTE = 65563,
            DET_TTI_ARROW = 65564,
            DET_POI_NAME = 65565,
            DET_RASTER_MAP = 65566,
            DET_BREAD_CRUMB_TRAIL = 65567,
            DET_EDGE_HIGHLIGHTING = 65568,
            DET_DIRECTION_ARROW = 65569,
            DET_CITY_BUILDINGS = 65570,
            DET_FPS_DISPLAY = 65571,
            DET_CROSSHAIR = 65572,
            DET_DEVDROP_BANNER = 65573,
            DET_FRAME_AROUND_MAP = 65574,
            DET_CORONA = 65575,
            DET_WATEREFFECT = 65576,
            DET_TREES = 65577,
            DET_RAIN = 65578,
            DET_CITYMODEL_ROUTE_TRANSPARENCY = 65579,
            DET_ROUTE_DESTINATION = 65580,
            DET_RANGE_DISPLAY = 65581,
            DET_POI_BRANDS = 65582,
            DET_WEATHER_MARKER = 65583,
            DET_WEATHER_OVERLAY = 65584,
            DET_WAYPOINT_ROUTE = 65585,
            DET_WAYPOINT_ROUTE_MARKER = 65586,
            DET_STENCIL = 65587
        };
        
        MapObject() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        MapObject(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        MapObject &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::BUILDINGS):
                case static_cast<int32_t>(Literal::TERRAIN):
                case static_cast<int32_t>(Literal::DET_POI):
                case static_cast<int32_t>(Literal::DET_TTI):
                case static_cast<int32_t>(Literal::DET_ONE_WAY_STREET_ARROW):
                case static_cast<int32_t>(Literal::DET_CITY_NAME):
                case static_cast<int32_t>(Literal::DET_ROAD_NAME):
                case static_cast<int32_t>(Literal::DET_MOTORWAY_EXIT_MARKER):
                case static_cast<int32_t>(Literal::DET_TRAFFIC_LIGHT):
                case static_cast<int32_t>(Literal::DET_TRAFFIC_LIGHTS_ALONG_ROUTE):
                case static_cast<int32_t>(Literal::DET_ROAD_ICON):
                case static_cast<int32_t>(Literal::DET_DTM):
                case static_cast<int32_t>(Literal::DET_LANDMARKS_3D):
                case static_cast<int32_t>(Literal::DET_FAVORITES):
                case static_cast<int32_t>(Literal::DET_ROUTE_BLOCKING):
                case static_cast<int32_t>(Literal::DET_ROAD):
                case static_cast<int32_t>(Literal::DET_POLYGON):
                case static_cast<int32_t>(Literal::DET_DESTINATION):
                case static_cast<int32_t>(Literal::DET_MANOEUVRE_MARKER):
                case static_cast<int32_t>(Literal::DET_LANE_GUIDANCE_MARKER):
                case static_cast<int32_t>(Literal::DET_ROUTE):
                case static_cast<int32_t>(Literal::DET_MANOEUVRE_ARROW):
                case static_cast<int32_t>(Literal::DET_TREKKING_TOUR):
                case static_cast<int32_t>(Literal::DET_TTI_EDGE_HIGHLIGHTING):
                case static_cast<int32_t>(Literal::DET_CITY_MARKER):
                case static_cast<int32_t>(Literal::DET_VEHICLE):
                case static_cast<int32_t>(Literal::DET_POLYGON_NAME):
                case static_cast<int32_t>(Literal::DET_OFF_ROAD_ROUTE):
                case static_cast<int32_t>(Literal::DET_TTI_ARROW):
                case static_cast<int32_t>(Literal::DET_POI_NAME):
                case static_cast<int32_t>(Literal::DET_RASTER_MAP):
                case static_cast<int32_t>(Literal::DET_BREAD_CRUMB_TRAIL):
                case static_cast<int32_t>(Literal::DET_EDGE_HIGHLIGHTING):
                case static_cast<int32_t>(Literal::DET_DIRECTION_ARROW):
                case static_cast<int32_t>(Literal::DET_CITY_BUILDINGS):
                case static_cast<int32_t>(Literal::DET_FPS_DISPLAY):
                case static_cast<int32_t>(Literal::DET_CROSSHAIR):
                case static_cast<int32_t>(Literal::DET_DEVDROP_BANNER):
                case static_cast<int32_t>(Literal::DET_FRAME_AROUND_MAP):
                case static_cast<int32_t>(Literal::DET_CORONA):
                case static_cast<int32_t>(Literal::DET_WATEREFFECT):
                case static_cast<int32_t>(Literal::DET_TREES):
                case static_cast<int32_t>(Literal::DET_RAIN):
                case static_cast<int32_t>(Literal::DET_CITYMODEL_ROUTE_TRANSPARENCY):
                case static_cast<int32_t>(Literal::DET_ROUTE_DESTINATION):
                case static_cast<int32_t>(Literal::DET_RANGE_DISPLAY):
                case static_cast<int32_t>(Literal::DET_POI_BRANDS):
                case static_cast<int32_t>(Literal::DET_WEATHER_MARKER):
                case static_cast<int32_t>(Literal::DET_WEATHER_OVERLAY):
                case static_cast<int32_t>(Literal::DET_WAYPOINT_ROUTE):
                case static_cast<int32_t>(Literal::DET_WAYPOINT_ROUTE_MARKER):
                case static_cast<int32_t>(Literal::DET_STENCIL):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MapObject &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MapObject &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MapObject &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MapObject &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MapObject &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MapObject &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct PanAction : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            PAN_START = 256,
            PAN_TO = 257,
            PAN_END = 258
        };
        
        PanAction() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        PanAction(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        PanAction &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::PAN_START):
                case static_cast<int32_t>(Literal::PAN_TO):
                case static_cast<int32_t>(Literal::PAN_END):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PanAction &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PanAction &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PanAction &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PanAction &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PanAction &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PanAction &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct Visibility : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            VISIBLE = 67,
            INVISIBLE = 68,
            FROZEN = 69
        };
        
        Visibility() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        Visibility(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        Visibility &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::VISIBLE):
                case static_cast<int32_t>(Literal::INVISIBLE):
                case static_cast<int32_t>(Literal::FROZEN):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Visibility &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Visibility &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Visibility &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Visibility &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Visibility &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Visibility &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct Level : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            LEVEL_1 = 80,
            LEVEL_2 = 81,
            LEVEL_3 = 82,
            LEVEL_4 = 83,
            LEVEL_5 = 84
        };
        
        Level() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        Level(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        Level &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::LEVEL_1):
                case static_cast<int32_t>(Literal::LEVEL_2):
                case static_cast<int32_t>(Literal::LEVEL_3):
                case static_cast<int32_t>(Literal::LEVEL_4):
                case static_cast<int32_t>(Literal::LEVEL_5):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Level &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Level &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Level &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Level &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Level &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Level &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct HeadingType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            CONSTANT_ANGLE = 112,
            TRACK_UP = 113,
            TOWARDS_TARGET = 114
        };
        
        HeadingType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        HeadingType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        HeadingType &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::CONSTANT_ANGLE):
                case static_cast<int32_t>(Literal::TRACK_UP):
                case static_cast<int32_t>(Literal::TOWARDS_TARGET):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const HeadingType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const HeadingType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const HeadingType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const HeadingType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const HeadingType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const HeadingType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct MapTheme : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            THEME_1 = 96,
            THEME_2 = 97,
            THEME_3 = 98,
            THEME_BMW_CLASSIC_DAY = 65539,
            THEME_BMW_CLASSIC_NIGHT = 65540,
            THEME_BMW_CLASSIC_TRAFFIC_DAY = 65541,
            THEME_BMW_CLASSIC_TRAFFIC_NIGHT = 65542,
            THEME_BMW_ALTERNATIVE_DAY = 65543,
            THEME_BMW_ALTERNATIVE_NIGHT = 65544,
            THEME_BMW_ALTERNATIVE_TRAFFIC_DAY = 65545,
            THEME_BMW_ALTERNATIVE_TRAFFIC_NIGHT = 65546,
            THEME_BMW_GUIDING = 65547,
            THEME_MINI_CLASSIC_DAY = 65548,
            THEME_MINI_CLASSIC_NIGHT = 65549,
            THEME_MINI_CLASSIC_TRAFFIC_DAY = 65550,
            THEME_MINI_CLASSIC_TRAFFIC_NIGHT = 65551,
            THEME_MINI_ALTERNATIVE_DAY = 65552,
            THEME_MINI_ALTERNATIVE_NIGHT = 65553,
            THEME_MINI_ALTERNATIVE_TRAFFIC_DAY = 65554,
            THEME_MINI_ALTERNATIVE_TRAFFIC_NIGHT = 65555,
            THEME_MINI_GUIDING = 65556,
            THEME_I_CLASSIC_DAY = 65557,
            THEME_I_CLASSIC_NIGHT = 65558,
            THEME_I_CLASSIC_TRAFFIC_DAY = 65559,
            THEME_I_CLASSIC_TRAFFIC_NIGHT = 65560,
            THEME_I_ALTERNATIVE_DAY = 65561,
            THEME_I_ALTERNATIVE_NIGHT = 65562,
            THEME_I_ALTERNATIVE_TRAFFIC_DAY = 65563,
            THEME_I_ALTERNATIVE_TRAFFIC_NIGHT = 65564,
            THEME_I_GUIDING = 65565
        };
        
        MapTheme() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        MapTheme(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        MapTheme &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::THEME_1):
                case static_cast<int32_t>(Literal::THEME_2):
                case static_cast<int32_t>(Literal::THEME_3):
                case static_cast<int32_t>(Literal::THEME_BMW_CLASSIC_DAY):
                case static_cast<int32_t>(Literal::THEME_BMW_CLASSIC_NIGHT):
                case static_cast<int32_t>(Literal::THEME_BMW_CLASSIC_TRAFFIC_DAY):
                case static_cast<int32_t>(Literal::THEME_BMW_CLASSIC_TRAFFIC_NIGHT):
                case static_cast<int32_t>(Literal::THEME_BMW_ALTERNATIVE_DAY):
                case static_cast<int32_t>(Literal::THEME_BMW_ALTERNATIVE_NIGHT):
                case static_cast<int32_t>(Literal::THEME_BMW_ALTERNATIVE_TRAFFIC_DAY):
                case static_cast<int32_t>(Literal::THEME_BMW_ALTERNATIVE_TRAFFIC_NIGHT):
                case static_cast<int32_t>(Literal::THEME_BMW_GUIDING):
                case static_cast<int32_t>(Literal::THEME_MINI_CLASSIC_DAY):
                case static_cast<int32_t>(Literal::THEME_MINI_CLASSIC_NIGHT):
                case static_cast<int32_t>(Literal::THEME_MINI_CLASSIC_TRAFFIC_DAY):
                case static_cast<int32_t>(Literal::THEME_MINI_CLASSIC_TRAFFIC_NIGHT):
                case static_cast<int32_t>(Literal::THEME_MINI_ALTERNATIVE_DAY):
                case static_cast<int32_t>(Literal::THEME_MINI_ALTERNATIVE_NIGHT):
                case static_cast<int32_t>(Literal::THEME_MINI_ALTERNATIVE_TRAFFIC_DAY):
                case static_cast<int32_t>(Literal::THEME_MINI_ALTERNATIVE_TRAFFIC_NIGHT):
                case static_cast<int32_t>(Literal::THEME_MINI_GUIDING):
                case static_cast<int32_t>(Literal::THEME_I_CLASSIC_DAY):
                case static_cast<int32_t>(Literal::THEME_I_CLASSIC_NIGHT):
                case static_cast<int32_t>(Literal::THEME_I_CLASSIC_TRAFFIC_DAY):
                case static_cast<int32_t>(Literal::THEME_I_CLASSIC_TRAFFIC_NIGHT):
                case static_cast<int32_t>(Literal::THEME_I_ALTERNATIVE_DAY):
                case static_cast<int32_t>(Literal::THEME_I_ALTERNATIVE_NIGHT):
                case static_cast<int32_t>(Literal::THEME_I_ALTERNATIVE_TRAFFIC_DAY):
                case static_cast<int32_t>(Literal::THEME_I_ALTERNATIVE_TRAFFIC_NIGHT):
                case static_cast<int32_t>(Literal::THEME_I_GUIDING):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MapTheme &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MapTheme &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MapTheme &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MapTheme &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MapTheme &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MapTheme &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: struct generated for DBus argument CreateMapViewInstance_mapViewSize
     */
    struct Dimension : CommonAPI::Struct<uint16_t, uint16_t> {
    	
    	Dimension() {
    	}
    	Dimension(const uint16_t &_horizontalSize, const uint16_t &_verticalSize)
    	{
    		std::get<0>(values_) = _horizontalSize;
    		std::get<1>(values_) = _verticalSize;
    	}
    	inline const uint16_t &getHorizontalSize() const { return std::get<0>(values_); }
    	inline void setHorizontalSize(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	inline const uint16_t &getVerticalSize() const { return std::get<1>(values_); }
    	inline void setVerticalSize(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const Dimension& _other) const {
                return (getHorizontalSize() == _other.getHorizontalSize() && getVerticalSize() == _other.getVerticalSize());
        }
    	inline bool operator!=(const Dimension &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::unordered_map<::v4::org::genivi::navigation::mapviewer::MapViewerControl::MapObject, bool, CommonAPI::EnumHasher<::v4::org::genivi::navigation::mapviewer::MapViewerControl::MapObject>> MapObjectVisibility;
    
    struct MapScaleUnit : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            METER = 50,
            MILE = 51,
            KM = 52,
            YARD = 53,
            FOOT = 54
        };
        
        MapScaleUnit() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        MapScaleUnit(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        MapScaleUnit &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::METER):
                case static_cast<int32_t>(Literal::MILE):
                case static_cast<int32_t>(Literal::KM):
                case static_cast<int32_t>(Literal::YARD):
                case static_cast<int32_t>(Literal::FOOT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MapScaleUnit &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MapScaleUnit &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MapScaleUnit &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MapScaleUnit &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MapScaleUnit &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MapScaleUnit &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct MapScaleType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            MIN = 64,
            MAX = 65,
            MID = 66
        };
        
        MapScaleType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        MapScaleType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        MapScaleType &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::MIN):
                case static_cast<int32_t>(Literal::MAX):
                case static_cast<int32_t>(Literal::MID):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const MapScaleType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const MapScaleType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const MapScaleType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const MapScaleType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const MapScaleType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const MapScaleType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct SelectableMapType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            MET_POI = 2,
            MET_POLYGON = 3,
            MET_EDGE = 4,
            MET_ROAD = 5,
            MET_ROAD_ICON = 6,
            MET_TTI_ICON = 7,
            MET_TTI_EDGE = 8,
            MET_CITY_MARKER = 9,
            MET_ROUTE = 10,
            MET_TREKKING_ROUTE = 11,
            MET_POSITION = 12,
            MET_LANDMARK = 13,
            MET_DESTINATION = 14,
            MET_FAVORITE = 15,
            MET_PICTURE = 16,
            MET_GENERIC_MARKER = 17,
            CUSTOM_ELEMENT = 288,
            CURRENT_POSITION = 289,
            WAYPOINT = 290,
            POI = 291,
            TRAFFIC_INCIDENT = 292,
            ROUTE = 293,
            GEOCOORDINATES = 294
        };
        
        SelectableMapType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        SelectableMapType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        SelectableMapType &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::MET_POI):
                case static_cast<int32_t>(Literal::MET_POLYGON):
                case static_cast<int32_t>(Literal::MET_EDGE):
                case static_cast<int32_t>(Literal::MET_ROAD):
                case static_cast<int32_t>(Literal::MET_ROAD_ICON):
                case static_cast<int32_t>(Literal::MET_TTI_ICON):
                case static_cast<int32_t>(Literal::MET_TTI_EDGE):
                case static_cast<int32_t>(Literal::MET_CITY_MARKER):
                case static_cast<int32_t>(Literal::MET_ROUTE):
                case static_cast<int32_t>(Literal::MET_TREKKING_ROUTE):
                case static_cast<int32_t>(Literal::MET_POSITION):
                case static_cast<int32_t>(Literal::MET_LANDMARK):
                case static_cast<int32_t>(Literal::MET_DESTINATION):
                case static_cast<int32_t>(Literal::MET_FAVORITE):
                case static_cast<int32_t>(Literal::MET_PICTURE):
                case static_cast<int32_t>(Literal::MET_GENERIC_MARKER):
                case static_cast<int32_t>(Literal::CUSTOM_ELEMENT):
                case static_cast<int32_t>(Literal::CURRENT_POSITION):
                case static_cast<int32_t>(Literal::WAYPOINT):
                case static_cast<int32_t>(Literal::POI):
                case static_cast<int32_t>(Literal::TRAFFIC_INCIDENT):
                case static_cast<int32_t>(Literal::ROUTE):
                case static_cast<int32_t>(Literal::GEOCOORDINATES):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SelectableMapType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SelectableMapType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SelectableMapType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SelectableMapType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SelectableMapType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SelectableMapType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: struct generated for DBus argument GetScaleList_scaleList
     */
    struct MapScale : CommonAPI::Struct<uint16_t, uint16_t, MapScaleUnit, uint32_t> {
    	
    	MapScale() {
    	}
    	MapScale(const uint16_t &_scaleId, const uint16_t &_scaleValue, const MapScaleUnit &_unit, const uint32_t &_millimetersPerPixel)
    	{
    		std::get<0>(values_) = _scaleId;
    		std::get<1>(values_) = _scaleValue;
    		std::get<2>(values_) = _unit;
    		std::get<3>(values_) = _millimetersPerPixel;
    	}
    	inline const uint16_t &getScaleId() const { return std::get<0>(values_); }
    	inline void setScaleId(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	inline const uint16_t &getScaleValue() const { return std::get<1>(values_); }
    	inline void setScaleValue(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline const MapScaleUnit &getUnit() const { return std::get<2>(values_); }
    	inline void setUnit(const MapScaleUnit &_value) { std::get<2>(values_) = _value; }
    	inline const uint32_t &getMillimetersPerPixel() const { return std::get<3>(values_); }
    	inline void setMillimetersPerPixel(const uint32_t &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const MapScale& _other) const {
                return (getScaleId() == _other.getScaleId() && getScaleValue() == _other.getScaleValue() && getUnit() == _other.getUnit() && getMillimetersPerPixel() == _other.getMillimetersPerPixel());
        }
    	inline bool operator!=(const MapScale &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: struct generated for DBus argument SetMapViewSaveArea_saveArea
     */
    struct MapViewArea : CommonAPI::Struct<double, double, double, double> {
    	
    	MapViewArea() {
    	}
    	MapViewArea(const double &_left, const double &_right, const double &_top, const double &_bottom)
    	{
    		std::get<0>(values_) = _left;
    		std::get<1>(values_) = _right;
    		std::get<2>(values_) = _top;
    		std::get<3>(values_) = _bottom;
    	}
    	inline const double &getLeft() const { return std::get<0>(values_); }
    	inline void setLeft(const double &_value) { std::get<0>(values_) = _value; }
    	inline const double &getRight() const { return std::get<1>(values_); }
    	inline void setRight(const double &_value) { std::get<1>(values_) = _value; }
    	inline const double &getTop() const { return std::get<2>(values_); }
    	inline void setTop(const double &_value) { std::get<2>(values_) = _value; }
    	inline const double &getBottom() const { return std::get<3>(values_); }
    	inline void setBottom(const double &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const MapViewArea& _other) const {
                return (getLeft() == _other.getLeft() && getRight() == _other.getRight() && getTop() == _other.getTop() && getBottom() == _other.getBottom());
        }
    	inline bool operator!=(const MapViewArea &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: struct generated for DBus argument SetMapViewPan_pixelCoordinates
     */
    struct Pixel : CommonAPI::Struct<uint16_t, uint16_t> {
    	
    	Pixel() {
    	}
    	Pixel(const uint16_t &_x, const uint16_t &_y)
    	{
    		std::get<0>(values_) = _x;
    		std::get<1>(values_) = _y;
    	}
    	inline const uint16_t &getX() const { return std::get<0>(values_); }
    	inline void setX(const uint16_t &_value) { std::get<0>(values_) = _value; }
    	inline const uint16_t &getY() const { return std::get<1>(values_); }
    	inline void setY(const uint16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const Pixel& _other) const {
                return (getX() == _other.getX() && getY() == _other.getY());
        }
    	inline bool operator!=(const Pixel &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: struct generated for DBus argument GetDisplayedRoutes_displayedRoutes
     */
    struct DisplayedRoute : CommonAPI::Struct<::v4::org::genivi::navigation::NavigationTypes::Handle, bool> {
    	
    	DisplayedRoute() {
    		std::get<1>(values_) = false;
    	}
    	DisplayedRoute(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const bool &_highlighted)
    	{
    		std::get<0>(values_) = _routeHandle;
    		std::get<1>(values_) = _highlighted;
    	}
    	inline const ::v4::org::genivi::navigation::NavigationTypes::Handle &getRouteHandle() const { return std::get<0>(values_); }
    	inline void setRouteHandle(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_value) { std::get<0>(values_) = _value; }
    	inline const bool &getHighlighted() const { return std::get<1>(values_); }
    	inline void setHighlighted(const bool _value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const DisplayedRoute& _other) const {
                return (getRouteHandle() == _other.getRouteHandle() && getHighlighted() == _other.getHighlighted());
        }
    	inline bool operator!=(const DisplayedRoute &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: struct generated for DBus argument DisplayCustomElements_customElementsElem4
     */
    struct AnchorPoint : CommonAPI::Struct<int16_t, int16_t> {
    	
    	AnchorPoint() {
    	}
    	AnchorPoint(const int16_t &_x, const int16_t &_y)
    	{
    		std::get<0>(values_) = _x;
    		std::get<1>(values_) = _y;
    	}
    	inline const int16_t &getX() const { return std::get<0>(values_); }
    	inline void setX(const int16_t &_value) { std::get<0>(values_) = _value; }
    	inline const int16_t &getY() const { return std::get<1>(values_); }
    	inline void setY(const int16_t &_value) { std::get<1>(values_) = _value; }
    	inline bool operator==(const AnchorPoint& _other) const {
                return (getX() == _other.getX() && getY() == _other.getY());
        }
    	inline bool operator!=(const AnchorPoint &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: struct generated for DBus argument DisplayCustomElements_customElements
     */
    struct CustomElement : CommonAPI::Struct<std::string, std::string, ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D, AnchorPoint> {
    	
    	CustomElement() {
    	}
    	CustomElement(const std::string &_name, const std::string &_iconUri, const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &_coordinate, const AnchorPoint &_elem4)
    	{
    		std::get<0>(values_) = _name;
    		std::get<1>(values_) = _iconUri;
    		std::get<2>(values_) = _coordinate;
    		std::get<3>(values_) = _elem4;
    	}
    	inline const std::string &getName() const { return std::get<0>(values_); }
    	inline void setName(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getIconUri() const { return std::get<1>(values_); }
    	inline void setIconUri(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &getCoordinate() const { return std::get<2>(values_); }
    	inline void setCoordinate(const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &_value) { std::get<2>(values_) = _value; }
    	inline const AnchorPoint &getElem4() const { return std::get<3>(values_); }
    	inline void setElem4(const AnchorPoint &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const CustomElement& _other) const {
                return (getName() == _other.getName() && getIconUri() == _other.getIconUri() && getCoordinate() == _other.getCoordinate() && getElem4() == _other.getElem4());
        }
    	inline bool operator!=(const CustomElement &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef std::unordered_map<::v4::org::genivi::navigation::NavigationTypes::Handle, ::v4::org::genivi::navigation::mapviewer::MapViewerControl::CustomElement> tCustomElementDict;
    typedef CommonAPI::Variant<int32_t, ::v4::org::genivi::navigation::NavigationTypes::Handle, CustomElement>  ElementValue;
    /**
     * description: struct generated for DBus argument SelectElementsOnMap_selectedElements
     */
    struct SelectedMapElement : CommonAPI::Struct<SelectableMapType, ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D, ElementValue> {
    	
    	SelectedMapElement() {
    	}
    	SelectedMapElement(const SelectableMapType &_type, const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &_position, const ElementValue &_value)
    	{
    		std::get<0>(values_) = _type;
    		std::get<1>(values_) = _position;
    		std::get<2>(values_) = _value;
    	}
    	inline const SelectableMapType &getType() const { return std::get<0>(values_); }
    	inline void setType(const SelectableMapType &_value) { std::get<0>(values_) = _value; }
    	inline const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &getPosition() const { return std::get<1>(values_); }
    	inline void setPosition(const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &_value) { std::get<1>(values_) = _value; }
    	inline const ElementValue &getValue() const { return std::get<2>(values_); }
    	inline void setValue(const ElementValue &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const SelectedMapElement& _other) const {
                return (getType() == _other.getType() && getPosition() == _other.getPosition() && getValue() == _other.getValue());
        }
    	inline bool operator!=(const SelectedMapElement &_other) const {
    		return !((*this) == _other);
    	}
    
    };
};

const char* MapViewerControl::getInterface() {
    return ("org.genivi.navigation.mapviewer.MapViewerControl");
}

CommonAPI::Version MapViewerControl::getInterfaceVersion() {
    return CommonAPI::Version(4, 0);
}

/**
 * description: struct generated for DBus argument CreateMapViewInstance_mapViewSize
 */
/**
 * description: struct generated for DBus argument GetScaleList_scaleList
 */
/**
 * description: struct generated for DBus argument SetMapViewSaveArea_saveArea
 */
/**
 * description: struct generated for DBus argument SetMapViewPan_pixelCoordinates
 */
/**
 * description: struct generated for DBus argument GetDisplayedRoutes_displayedRoutes
 */
/**
 * description: struct generated for DBus argument DisplayCustomElements_customElementsElem4
 */
/**
 * description: struct generated for DBus argument DisplayCustomElements_customElements
 */
/**
 * description: struct generated for DBus argument SelectElementsOnMap_selectedElements
 */

} // namespace mapviewer
} // namespace navigation
} // namespace genivi
} // namespace org
} // namespace v4

namespace CommonAPI {
}


// Compatibility
namespace v4_0 = v4;

#endif // V4_ORG_GENIVI_NAVIGATION_MAPVIEWER_MAP_VIEWER_CONTROL_HPP_
