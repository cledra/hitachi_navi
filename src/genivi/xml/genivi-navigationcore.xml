<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="introspect.xsl"?>
<!-- SPDX-License-Identifier: MPL-2.0
     Copyright (C) 2014, BMW Car IT GmbH, Continental Automotive GmbH, PCA Peugeot Citroën, XS Embedded GmbH,   TomTom International B.V., Alpine Electronics R&D Europe GmbH, AISIN AW CO., LTD.,  Neusoft Technology Solutions GmbH, Jaguar Land Rover Limited, Visteon Corporation
     This Source Code Form is subject to the terms of the
     Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with
     this file, you can obtain one at http://mozilla.org/MPL/2.0/.
-->
<node xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" name="/org/genivi/navigationcore" xsi:noNamespaceSchemaLocation="introspect.xsd">
  <interface name="org.genivi.navigationcore.Session">
    <version>3.0.0 (22-01-2014)</version>
    <doc>
      <line>Session = This interface offers functions to create and delete sessions</line>
    </doc>
    <method name="GetVersion">
      <doc>
        <line>GetVersion = This method returns the API version implemented by the server application</line>
      </doc>
      <arg name="version" type="(qqqs)" direction="out">
        <doc>
          <line>version = struct(major,minor,micro,date)</line>
          <line>major = when the major changes, then backward compatibility with previous releases is not granted</line>
          <line>minor = when the minor changes, then backward compatibility with previous releases is granted, but something changed in the implementation of the API (e.g. new methods may have been added)</line>
          <line>micro = when the micro changes, then backward compatibility with previous releases is granted (bug fixes or documentation modifications)</line>
          <line>date = release date (e.g. 21-06-2011)</line>
        </doc>
      </arg>
    </method>
    <method name="CreateSession">
      <doc>
        <line>CreateSession = This method creates a new session</line>
      </doc>
      <arg name="client" type="s" direction="in">
        <doc>
          <line>client = name or identifier of the client application that requests a new session</line>
          <line>The navigation core must internally associate this name to the returned session handle</line>
          <line>This parameter can be used to identify the client application and determine if a given feature is enabled for it</line>
        </doc>
      </arg>
      <arg name="sessionHandle" type="u" direction="out">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Session.Error.NoMoreSessionHandles">
        <doc>
          <line>This error is generated if no more session handles are available</line>
        </doc>
      </error>
    </method>
    <method name="DeleteSession">
      <doc>
        <line>DeleteSession = This method deletes a session and its associated resources</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Session.Error.SessionNotAvailable">
        <doc>
          <line>This error is generated if an application tries to delete a session handle that is not available</line>
        </doc>
      </error>
    </method>
    <method name="GetSessionStatus">
      <doc>
        <line>GetSessionStatus = This method returns whether a given session handle is available or not (for example because it was deleted)</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="sessionStatus" type="i" direction="out">
        <doc>
          <line>sessionStatus = enum(INVALID,AVAILABLE,NOT_AVAILABLE)</line>
        </doc>
      </arg>
    </method>
    <method name="GetAllSessions">
      <doc>
        <line>GetAllSessions = This method returns a list of all available sessions</line>
      </doc>
      <arg name="sessionsList" type="a(us)" direction="out">
        <doc>
          <line>sessionsList = array[struct(sessionHandle,client)]</line>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
          <line>client = name or identifier of the client application that requested the sessionHandle</line>
        </doc>
      </arg>
    </method>
    <signal name="SessionDeleted">
      <doc>
        <line>SessionDeleted = This signal is emitted when a session is deleted</line>
      </doc>
      <arg name="sessionHandle" type="u">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
    </signal>
  </interface>
  <interface name="org.genivi.navigationcore.Routing">
    <version>3.0.0 (22-01-2014)</version>
    <doc>
      <line>Routing = This interface offers functions that implement the routing functionality of a navigation system</line>
    </doc>
    <method name="GetVersion">
      <doc>
        <line>GetVersion = This method returns the API version implemented by the server application</line>
      </doc>
      <arg name="version" type="(qqqs)" direction="out">
        <doc>
          <line>version = struct(major,minor,micro,date)</line>
          <line>major = when the major changes, then backward compatibility with previous releases is not granted</line>
          <line>minor = when the minor changes, then backward compatibility with previous releases is granted, but something changed in the implementation of the API (e.g. new methods may have been added)</line>
          <line>micro = when the micro changes, then backward compatibility with previous releases is granted (bug fixes or documentation modifications)</line>
          <line>date = release date (e.g. 21-06-2011)</line>
        </doc>
      </arg>
    </method>
    <method name="CreateRoute">
      <doc>
        <line>CreateRoute = This method creates a route</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="out">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Routing.Error.NoMoreRouteHandles">
        <doc>
          <line>This error is generated if no more routing handles are available</line>
        </doc>
      </error>
    </method>
    <method name="DeleteRoute">
      <doc>
        <line>DeleteRoute = This method deletes a route and its associated resources</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Routing.Error.RouteNotAvailable">
        <doc>
          <line>This error is generated if an application tries to delete a route handle that is not available</line>
        </doc>
      </error>
      <error name="org.genivi.navigationcore.Routing.Error.OperationNotAllowed">
        <doc>
          <line>This error is generated if an application tries to delete a route which is not created manually (e.g. an alternative route calculated in the background)</line>
        </doc>
      </error>
    </method>
    <signal name="RouteDeleted">
      <doc>
        <line>RouteDeleted = This signal is emitted to inform clients that the current route has been deleted</line>
      </doc>
      <arg name="routeHandle" type="u">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
    </signal>
    <method name="SetCostModel">
      <doc>
        <line>SetCostModel = This method sets the cost model</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="costModel" type="i" direction="in">
        <doc>
          <line>costModel = enum(INVALID,FASTEST,SHORTEST,ECOLOGICAL,SCENIC,EASY,OFF_ROAD,BALANCED,CHEAPEST, ... )</line>
          <line>FASTEST = least time to reach the destination </line>
          <line>SHORTEST = shortest distance to destination </line>
          <line>ECOLOGICAL = least fuel or electric charge to destination </line>
          <line>SCENIC = most scenic route to destination </line>
          <line>EASY = least number of turns to reach the destination </line>
          <line>OFF_ROAD = a distance-optimised route between points that are not covered by road mappings</line>
          <line>BALANCED = trade-off between FASTEST and SHORTEST (e.g. 50% FASTEST and 50% SHORTEST) </line>
          <line>CHEAPEST = least fuel or electric charge to destination taking pricing into account </line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Routing.Error.OperationNotAllowed">
        <doc>
          <line>This error is generated if an application tries to set a cost model for a route which is not created manually (e.g. an alternative route calculated in the background)</line>
        </doc>
      </error>
    </method>
    <method name="GetCostModel">
      <doc>
        <line>GetCostModel = This method retrieves the selected cost model</line>
      </doc>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="costModel" type="i" direction="out">
        <doc>
          <line>costModel = enum(INVALID,FASTEST,SHORTEST,ECOLOGICAL,SCENIC,EASY,OFF_ROAD,BALANCED,CHEAPEST, ... )</line>
          <line>FASTEST = least time to reach the destination </line>
          <line>SHORTEST = shortest distance to destination </line>
          <line>ECOLOGICAL = least fuel or electric charge to destination </line>
          <line>SCENIC = most scenic route to destination </line>
          <line>EASY = least number of turns to reach the destination </line>
          <line>OFF_ROAD = a distance-optimised route between points that are not covered by road mappings</line>
          <line>BALANCED = trade-off between FASTEST and SHORTEST (e.g. 50% FASTEST and 50% SHORTEST) </line>
          <line>CHEAPEST = least fuel or electric charge to destination taking pricing into account </line>
        </doc>
      </arg>
    </method>
    <method name="GetSupportedCostModels">
      <doc>
        <line>GetSupportedCostModels = This method retrieves a list of supported cost models</line>
      </doc>
      <arg name="costModelsList" type="ai" direction="out">
        <doc>
          <line>costModelsList = array[costModel]</line>
          <line>costModel = enum(INVALID,FASTEST,SHORTEST,ECOLOGICAL,SCENIC,EASY,OFF_ROAD,BALANCED,CHEAPEST, ... )</line>
          <line>FASTEST = least time to reach the destination </line>
          <line>SHORTEST = shortest distance to destination </line>
          <line>ECOLOGICAL = least fuel or electric charge to destination </line>
          <line>SCENIC = most scenic route to destination </line>
          <line>EASY = least number of turns to reach the destination </line>
          <line>OFF_ROAD = a distance-optimised route between points that are not covered by road mappings</line>
          <line>BALANCED = trade-off between FASTEST and SHORTEST (e.g. 50% FASTEST and 50% SHORTEST) </line>
          <line>CHEAPEST = least fuel or electric charge to destination taking pricing into account </line>
        </doc>
      </arg>
    </method>
    <method name="SetRoutePreferences">
      <doc>
        <line>SetRoutePreferences = This method sets a list of route preferences</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="countryCode" type="s" direction="in">
        <doc>
          <line>countryCode = ISO 3166‐1 alpha 3 country code (upper case)</line>
          <line>If this argument is an empty string, it means that the preferences apply to all countries</line>
        </doc>
      </arg>
      <arg name="roadPreferenceList" type="a(ii)" direction="in">
        <doc>
          <line>roadPreferenceList = array[preference]</line>
          <line>preference = struct(preferenceMode,preferenceSource)</line>
          <line>preferenceMode = enum(PROHIBIT,AVOID,USE,PREFER)</line>
          <line>preferenceMode = PROHIBIT. Routing module must not calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = AVOID. Routing module should not calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = USE. Routing module should calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = PREFER. Routing module should calculate a planned route including as much as possible sections matching given avoidance source.</line>
          <line>preferenceSource = enum(FERRY,TOLL_ROADS,TUNNELS,HIGHWAYS_MOTORWAYS,VEHICLE_SIZE_LIMIT,CRIME_AREAS)</line>
        </doc>
      </arg>
      <arg name="conditionPreferenceList" type="a(ii)" direction="in">
        <doc>
          <line>conditionPreferenceList = array[preference]</line>
          <line>preference = struct(preferenceMode,preferenceSource)</line>
          <line>preferenceMode = enum(USE,IGNORE)</line>
          <line>preferenceSource = enum(TRAFFIC_REALTIME, ...)</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Routing.Error.OperationNotAllowed">
        <doc>
          <line>This error is generated if an application tries to set route preferences for a route which is not created manually (e.g. an alternative route calculated in the background)</line>
        </doc>
      </error>
      <error name="org.genivi.navigationcore.Routing.Error.RoutePreferenceNotSupported">
        <doc>
          <line>This error is generated if an application tries to set a route preference which is not supported (e.g. (USE,CRIME_AREA)). The preferences which are not supported are product dependent.</line>
        </doc>
      </error>
    </method>
    <method name="GetRoutePreferences">
      <doc>
        <line>GetRoutePreferences = This method retrieves a list of selected route preferences</line>
      </doc>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="countryCode" type="s" direction="in">
        <doc>
          <line>countryCode = ISO 3166‐1 alpha 3 country code (upper case)</line>
          <line>If this argument is an empty string, it means that the preferences apply to all countries</line>
        </doc>
      </arg>
      <arg name="roadPreferenceList" type="a(ii)" direction="out">
        <doc>
          <line>roadPreferenceList = array[preference]</line>
          <line>preference = struct(preferenceMode,preferenceSource)</line>
          <line>preferenceMode = enum(PROHIBIT,AVOID,USE,PREFER)</line>
          <line>preferenceMode = PROHIBIT. Routing module must not calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = AVOID. Routing module should not calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = USE. Routing module should calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = PREFER. Routing module should calculate a planned route including as much as possible sections matching given avoidance source.</line>
          <line>preferenceSource = enum(FERRY,TOLL_ROADS,TUNNELS,HIGHWAYS_MOTORWAYS,VEHICLE_SIZE_LIMIT,CRIME_AREAS)</line>
        </doc>
      </arg>
      <arg name="conditionPreferenceList" type="a(ii)" direction="out">
        <doc>
          <line>conditionPreferenceList = array[preference]</line>
          <line>preference = struct(preferenceMode,preferenceSource)</line>
          <line>preferenceMode = enum(USE,IGNORE)</line>
          <line>preferenceSource = enum(TRAFFIC_REALTIME, ...)</line>
        </doc>
      </arg>
    </method>
    <method name="GetSupportedRoutePreferences">
      <doc>
        <line>GetSupportedRoutePreferences = This method retrieves a list of supported route preferences</line>
      </doc>
      <arg name="routePreferencesList" type="a(ii)" direction="out">
        <doc>
          <line>routePreferencesList = array[preference]</line>
          <line>preference = struct(preferenceMode,preferenceSource)</line>
          <line>preferenceMode = enum(PROHIBIT,AVOID,USE,PREFER)</line>
          <line>preferenceMode = PROHIBIT. Routing module must not calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = AVOID. Routing module should not calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = USE. Routing module should calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = PREFER. Routing module should calculate a planned route including as much as possible sections matching given avoidance source.</line>
          <line>preferenceSource = enum(FERRY,TOLL_ROADS,TUNNELS,HIGHWAYS_MOTORWAYS,VEHICLE_SIZE_LIMIT,CRIME_AREAS)</line>
        </doc>
      </arg>
      <arg name="conditionPreferenceList" type="a(ii)" direction="out">
        <doc>
          <line>conditionPreferenceList = array[preference]</line>
          <line>preference = struct(preferenceMode,preferenceSource)</line>
          <line>preferenceMode = enum(USE,IGNORE)</line>
          <line>preferenceSource = enum(TRAFFIC_REALTIME, ...)</line>
        </doc>
      </arg>
    </method>
    <method name="SetRouteSchedule">
      <doc>
        <line> SetRouteSchedule = This method sets the time schedule for the route to be calculated</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeSchedule" type="a{iu}" direction="in">
        <doc>
          <line>routeSchedule = array[detail]</line>
          <line>detail = dictionary[key,value]</line>
          <line>dictionary = array of tuples (key,value)</line>
          <line>key = enum(ARRIVAL_TIME, ARRIVAL_DATE,DEPARTURE_TIME, DEPARTURE_DATE)</line>
          <line>key = ARRIVAL_TIME, value of type 'u', that represents the arrival time is expressed in seconds since mid-night (UTC)</line>
          <line>key = ARRIVAL_DATE, value of type 'u', that represents the arrival date is either a calendar date (the number of days since 1 Jan 2000) or a weekday indication. For weekday indication the values 0 till 6 are used (0 = Saturday, 1 = Sunday, 2 = Monday, ..., 6 = Friday)</line>
          <line>key = DEPARTURE_TIME, value of type 'u', that represents the departure time is expressed in seconds since mid-night (UTC)</line>
          <line>key = DEPARTURE_DATE, value of type 'u', that represents the departure date is either a calendar date (the number of days since 1 Jan 2000) or a weekday indication. For weekday indication the values 0 till 6 are used (0 = Saturday, 1 = Sunday, 2 = Monday, ..., 6 = Friday)</line>
        </doc>
      </arg>
    </method>
    <method name="GetRouteSchedule">
      <doc>
        <line> GetRouteSchedule = This method gets the time schedule for the route to be calculated</line>
      </doc>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="valuesToReturn" type="ai" direction="in">
        <doc>
          <line>valuesToReturn= array[value]</line>
          <line>value= enum(ARRIVAL_TIME, ARRIVAL_DATE,DEPARTURE_TIME, DEPARTURE_DATE)</line>
        </doc>
      </arg>
      <arg name="routeSchedule" type="a{iu}" direction="out">
        <doc>
          <line> routeSchedule = array[detail]</line>
          <line>detail = dictionary[key,value]</line>
          <line>dictionary = array of tuples (key,value)</line>
          <line>key = enum(ARRIVAL_TIME, ARRIVAL_DATE,DEPARTURE_TIME, DEPARTURE_DATE)</line>
          <line>key = ARRIVAL_TIME, value of type 'u', that represents the arrival time is expressed in seconds since mid-night (UTC)</line>
          <line>key = ARRIVAL_DATE, value of type 'u', that represents the arrival date is either a calendar date (the number of days since 1 Jan 2000) or a weekday indication. For weekday indication the values 0 till 6 are used (0 = Saturday, 1 = Sunday, 2 = Monday, ..., 6 = Friday)</line>
          <line>key = DEPARTURE_TIME, value of type 'u', that represents the departure time is expressed in seconds since mid-night (UTC)</line>
          <line>key = DEPARTURE_DATE, value of type 'u', that represents the departure date is either a calendar date (the number of days since 1 Jan 2000) or a weekday indication. For weekday indication the values 0 till 6 are used (0 = Saturday, 1 = Sunday, 2 = Monday, ..., 6 = Friday)</line>
        </doc>
      </arg>
    </method>
    <method name="SetTransportationMeans">
      <doc>
        <line>SetTransportationMeans = This method sets a list of means of transportation that must be considered when calculating a route</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="transportationMeansList" type="ai" direction="in">
        <doc>
          <line>transportationMeansList = array[transportationMeans]</line>
          <line>transportationMeans = enum(INVALID,BY_CAR,ON_FOOT,LONG_RANGE_TRAINS,PUBLIC_TRANSPORTATION,BY_BICYCLE,BY_TRUCK, ... )</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Routing.Error.OperationNotAllowed">
        <doc>
          <line>This error is generated if an application tries to set transportation means for a route which is not created manually (e.g. an alternative route calculated in the background)</line>
        </doc>
      </error>
    </method>
    <method name="GetTransportationMeans">
      <doc>
        <line>GetTransportationMeans = This method retrieves the selected means of transportation</line>
      </doc>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="transportationMeansList" type="ai" direction="out">
        <doc>
          <line>transportationMeansList = array[transportationMeans]</line>
          <line>transportationMeans = enum(INVALID,BY_CAR,ON_FOOT,LONG_RANGE_TRAINS,PUBLIC_TRANSPORTATION,BY_BICYCLE,BY_TRUCK, ... )</line>
        </doc>
      </arg>
    </method>
    <method name="GetSupportedTransportationMeans">
      <doc>
        <line>GetSupportedTransportationMeans = This method retrieves a list of supported means of transportation</line>
      </doc>
      <arg name="transportationMeansList" type="ai" direction="out">
        <doc>
          <line>transportationMeansList = array[transportationMeans]</line>
          <line>transportationMeans = enum(INVALID,BY_CAR,ON_FOOT,LONG_RANGE_TRAINS,PUBLIC_TRANSPORTATION,BY_BICYCLE,BY_TRUCK, ... )</line>
        </doc>
      </arg>
    </method>
    <method name="SetExcludedAreas">
      <doc>
        <line>SetExcludedAreas = This method sets the areas to be excluded when calculating a route</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="excludedAreas" type="aa(dd)" direction="in">
        <doc>
          <line>excludedAreas = array[array(lat,lon)]</line>
          <line>excludedAreas = array[convexPolygon]</line>
          <line>convexPolygon = array[lat,lon] </line>
          <line>lat = latitude of a vertex of the polygon in format %3.6f. Range [-90:+90]. Example: 48.053250</line>
          <line>lon = longitude of a vertex of the polygon in format %3.6f. Range [-180:+180]. Example: 48.053250</line>
          <line>Note: a polygon must have at least 3 vertexes</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Routing.Error.OperationNotAllowed">
        <doc>
          <line>This error is generated if an application tries to set excluded areas for a route which is not created manually (e.g. an alternative route calculated in the background)</line>
        </doc>
      </error>
    </method>
    <method name="GetExcludedAreas">
      <doc>
        <line>GetExcludedAreas = This method retrieves the areas to be excluded when calculating a route</line>
      </doc>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="excludedAreas" type="aa(dd)" direction="out">
        <doc>
          <line>excludedAreas = array[array(lat,lon)]</line>
          <line>excludedAreas = array[convexPolygon]</line>
          <line>convexPolygon = array[lat,lon]</line>
          <line>lat = latitude of a vertex of the polygon in format %3.6f. Range [-90:+90]. Example: 48.053250</line>
          <line>lon = longitude of a vertex of the polygon in format %3.6f. Range [-180:+180]. Example: 48.053250</line>
          <line>Note: pass an empty array to remove previously selected excluded areas</line>
        </doc>
      </arg>
    </method>
    <method name="SetWaypoints">
      <doc>
        <line>SetWaypoints = This method sets a list of waypoints</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="startFromCurrentPosition" type="b" direction="in">
        <doc>
          <line>startFromCurrentPosition = flag indicating if the current position is used as starting point</line>
        </doc>
      </arg>
      <arg name="waypointsList" type="aa{i(yv)}" direction="in">
        <doc>
          <line>waypointsList = array[waypoint]</line>
          <line>waypoint = tuple (key,value)</line>
          <line>key = enum(INVALID,WAYPOINT_TYPE,LOCATION_INPUT,LATITUDE,LONGITUDE,ALTITUDE, ... )</line>
          <line>key = WAYPOINT_TYPE, value = value of type 'q', that represents an enum(INVALID,SOFT_POINT,HARD_POINT, ... )</line>
          <line>key = LOCATION_INPUT, value = value of type 'ay'. This is a byte array whose interpretation is left to the navigation core</line>
          <line>key = LATITUDE, value = value of type 'd', that expresses the latitude of the starting point in format %3.6f. Range [-90:+90]. Example: 48.053250</line>
          <line>key = LONGITUDE, value = value of type 'd', that expresses the longitude of the starting point in format %3.6f. Range [-180:+180]. Example: 8.324500</line>
          <line>key = ALTITUDE, value = value of type 'i', that expresses the altitude of the starting point in meters</line>
          <line>Note: if the flag StartFromCurrentPosition=true, then at least one waypoint must be provided (destination)</line>
          <line>Note: if the flag StartFromCurrentPosition=false, then at least two waypoints must be provided (starting point and destination)</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Routing.Error.WaypointCannotBeChanged">
        <doc>
          <line>This error is sent when a client application tries to change the waypoints while the route guidance is active</line>
        </doc>
      </error>
      <error name="org.genivi.navigationcore.Routing.Error.TooManyWaypoints">
        <doc>
          <line>This error is sent when a client application tries to set a number of waypoints that exceeds the system capabilities</line>
        </doc>
      </error>
      <error name="org.genivi.navigationcore.Routing.Error.OperationNotAllowed">
        <doc>
          <line>This error is generated if an application tries to set waypoints for a route which is not created manually (e.g. an alternative route calculated in the background)</line>
        </doc>
      </error>
    </method>
    <method name="GetWaypoints">
      <doc>
        <line>GetWaypoints = This method retrieves a list of waypoints</line>
      </doc>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="startFromCurrentPosition" type="b" direction="out">
        <doc>
          <line>startFromCurrentPosition = flag indicating if the current position is used as starting point</line>
        </doc>
      </arg>
      <arg name="waypointsList" type="aa{i(yv)}" direction="out">
        <doc>
          <line>waypointsList = array[waypoint]</line>
          <line>waypoint = tuple (key,value)</line>
          <line>key = enum(INVALID,WAYPOINT_TYPE,LOCATION_INPUT,LATITUDE,LONGITUDE,ALTITUDE, ... )</line>
          <line>key = WAYPOINT_TYPE, value = value of type 'q', that represents an enum(INVALID,SOFT_POINT,HARD_POINT, ... )</line>
          <line>key = LOCATION_INPUT, value = value of type 'ay'. This is a byte array whose interpretation is left to the navigation core</line>
          <line>key = LATITUDE, value = value of type 'd', that expresses the latitude of the starting point in format %3.6f. Range [-90:+90]. Example: 48.053250</line>
          <line>key = LONGITUDE, value = value of type 'd', that expresses the longitude of the starting point in format %3.6f. Range [-180:+180]. Example: 8.324500</line>
          <line>key = ALTITUDE, value = value of type 'i', that expresses the altitude of the starting point in meters</line>
        </doc>
      </arg>
    </method>
    <method name="CalculateRoute">
      <doc>
        <line>CalculateRoute = This method starts a route calculation</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Routing.Error.OperationNotAllowed">
        <doc>
          <line>This error is generated if an application tries to calculate a route which is not created manually (e.g. an alternative route calculated in the background)</line>
        </doc>
      </error>
    </method>
    <method name="CancelRouteCalculation">
      <doc>
        <line>CancelRouteCalculation = This method cancels a route calculation</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
    </method>
    <signal name="RouteCalculationCancelled">
      <doc>
        <line>RouteCalculationCancelled = This signal informs a client that a route calculation was cancelled</line>
      </doc>
      <arg name="routeHandle" type="u">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
    </signal>
    <signal name="RouteCalculationSuccessful">
      <doc>
        <line>RouteCalculationSuccessful = This signal informs a client that a route calculation was successful</line>
      </doc>
      <arg name="routeHandle" type="u">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="unfullfilledPreferences" type="a{ii}">
        <doc>
          <line>unfullfilledPreferences = array[preference]</line>
          <line>preference = tuple(preferenceMode,preferenceSource)</line>
          <line>preferenceMode = enum(PROHIBIT,AVOID,USE,PREFER)</line>
          <line>preferenceMode = PROHIBIT. Routing module must not calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = AVOID. Routing module should not calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = USE. Routing module should calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = PREFER. Routing module should calculate a planned route including as much as possible sections matching given avoidance source.</line>
          <line>preferenceSource = enum(FERRY,TOLL_ROADS,TUNNELS,HIGHWAYS_MOTORWAYS,VEHICLE_SIZE_LIMIT,CRIME_AREAS)</line>
        </doc>
      </arg>
    </signal>
    <signal name="RouteCalculationFailed">
      <doc>
        <line>RouteCalculationFailed = This signal informs a client that a route calculation failed</line>
      </doc>
      <arg name="routeHandle" type="u">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="errorCode" type="i">
        <doc>
          <line>errorCode = enum(INVALID,UNMATCHED_POSITION,UNREACHABLE_DESTINATION,UNFULFILLED_PREFERENCE_MODE, ... )</line>
          <line>errorCode = UNFULFILLED_PREFERENCE_MODE. Refer to unfullfilledPreferences to see which routing preferences could not be met causing routing calculation to fail; for any other value the argument unfulfilledPreferences should be ignored. </line>
        </doc>
      </arg>
      <arg name="unfullfilledPreferences" type="a{ii}">
        <doc>
          <line>unfullfilledPreferences = array[preference]</line>
          <line>preference = tuple(preferenceMode,preferenceSource)</line>
          <line>preferenceMode = enum(PROHIBIT,AVOID,USE,PREFER)</line>
          <line>preferenceMode = PROHIBIT. Routing module must not calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = AVOID. Routing module should not calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = USE. Routing module should calculate a planned route including sections matching given avoidance source.</line>
          <line>preferenceMode = PREFER. Routing module should calculate a planned route including as much as possible sections matching given avoidance source.</line>
          <line>preferenceSource = enum(FERRY,TOLL_ROADS,TUNNELS,HIGHWAYS_MOTORWAYS,VEHICLE_SIZE_LIMIT,CRIME_AREAS)</line>
        </doc>
      </arg>
    </signal>
    <signal name="RouteCalculationProgressUpdate">
      <doc>
        <line>RouteCalculationProgressUpdate = This signal informs a client about a route calculation progress</line>
      </doc>
      <arg name="routeHandle" type="u">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="status" type="i">
        <doc>
          <line>status = enum(INVALID,CALCULATION_OK,NO_POSITION, ... )</line>
        </doc>
      </arg>
      <arg name="percentage" type="y">
        <doc>
          <line>percentage = progress status. Range [0:100]</line>
        </doc>
      </arg>
    </signal>
    <method name="CalculateRoutes">
      <doc>
        <line>CalculateRoutes = This method allows a client to calculate alternative routes that differs from a list of already calculated routes</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="calculatedRoutesList" type="au" direction="in">
        <doc>
          <line>calculatedRoutesList = array[calculatedRoute]</line>
          <line>calculatedRoute = Handle identifying an already calculated route. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="alternativeRoutesList" type="au" direction="out">
        <doc>
          <line>alternativeRoutesList = array[alternativeRoute]</line>
          <line>alternativeRoute = Handle identifying an alternative route. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Routing.Error.OperationNotAllowed">
        <doc>
          <line>This error is generated if an application tries to calculate an alternative to a route which is not created manually (e.g. an alternative route calculated in the background)</line>
        </doc>
      </error>
    </method>
    <method name="GetRouteSegments">
      <doc>
        <line>GetRouteSegments = This method retrieves a list of segments for a given route starting from the one closest to the current position to the one closest to the destination</line>
      </doc>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="detailLevel" type="n" direction="in">
        <doc>
          <line>detailLevel = detail level</line>
        </doc>
      </arg>
      <arg name="valuesToReturn" type="ai" direction="in">
        <doc>
          <line>valuesToReturn= array[key]</line>
          <line>key = enum(INVALID,LINK-ID,INTERMEDIATE_POINTS,START_LATITUDE,START_LONGITUDE,START_ALTITUDE,</line>
          <line>END_LATITUDE,END_LONGITUDE,END_ALTITUDE,ROAD_NAME,ROAD_NUMBER,DISTANCE,TIME,MANEUVER,INSTRUCTION,</line>
          <line>BORDER_CROSSING,TIME_ZONE,DAYLIGHT_SAVING_TIME,ADDITIONAL_INFORMATION,HIGHWAY_EXIT, ... , ALL)</line>
        </doc>
      </arg>
      <arg name="numberOfSegments" type="u" direction="in">
        <doc>
          <line>numberOfSegments = number of segments to be retrieved</line>
        </doc>
      </arg>
      <arg name="offset" type="u" direction="in">
        <doc>
          <line>offset = offset from the beginning of the list</line>
        </doc>
      </arg>
      <arg name="totalNumberOfSegments" type="u" direction="out">
        <doc>
          <line>totalNumberOfSegments = total number of segments</line>
        </doc>
      </arg>
      <arg name="routeSegments" type="aa{i(yv)}" direction="out">
        <doc>
          <line>routeSegments = array[segment]</line>
          <line>segment = tuple(key,value)</line>
          <line>Note: a segment is the shortest navigable stretch of a route (e.g. the stretch between two adjacent junctions)</line>
          <line>key = enum(INVALID,LINK-ID,INTERMEDIATE_POINTS,START_LATITUDE,START_LONGITUDE,START_ALTITUDE,</line>
          <line>END_LATITUDE,END_LONGITUDE,END_ALTITUDE,ROAD_NAME,ROAD_NUMBER,DISTANCE,TIME,MANEUVER,INSTRUCTION,</line>
          <line>BORDER_CROSSING,TIME_ZONE,DAYLIGHT_SAVING_TIME,ADDITIONAL_INFORMATION,HIGHWAY_EXIT, ... )</line>
          <line>key = LINK-ID, value = value of type 'ay', that represents a link-ID in a format whose interpretation is left to the navigationcore</line>
          <line>key = START_LATITUDE, value = value of type 'd', that expresses the latitude of the starting point in format %3.6f. Range [-90:+90]. Example: 48.053250</line>
          <line>key = END_LATITUDE, value = value of type 'd', that expresses the latitude of the ending point in format %3.6f. Range [-90:+90]. Example: 48.053250</line>
          <line>Note: END_LATITUDE can be omitted, if it coincides with the latitude of the start point of the next segment</line>
          <line>key = START_LONGITUDE, value = value of type 'd', that expresses the longitude of the starting point in format %3.6f. Range [-180:+180]. Example: 8.321000</line>
          <line>key = END_LONGITUDE, value = value of type 'd', that expresses the longitude of the ending point in format %3.6f. Range [-180:+180]. Example: 8.321000</line>
          <line>Note: END_LONGITUDE can be omitted, if it coincides with the longitude of the start point of the next segment</line>
          <line>key = START_ALTITUDE, value = value of type 'i', that expresses the altitude relative to the ground of the starting point in meters</line>
          <line>key = END_ALTITUDE, value = value of type 'i', that expresses the altitude relative to the ground of the ending point in meters</line>
          <line>Note: END_ALTITUDE can be omitted, if it coincides with the altitude of the start point of the next segment</line>
          <line>key = INTERMEDIATE_POINTS, value = value of type 'a(qddd)', that expresses an array of intermediate points</line>
          <line>Note: an intermedate point is expressed as a struct(type,latitude,longitude,altitude), where type = enum(INVALID,HARD_POINT,SOFT_POINT, ... )</line>
          <line>key = ROAD_NUMBER, value = value of type 's', that expresses the road number</line>
          <line>key = ROAD_NAME, value = value of type 's', that expresses the road name</line>
          <line>key = DISTANCE, value = value of type 'u', that identifies distance to the next segment in meters</line>
          <line>key = TIME, value = value of type 'u', that identifies time to travel to the next segment in seconds</line>
          <line>key = MANEUVER, value = value of type 'a(qqaq)', that identifies a pictogram that describes the next maneuver (OPTIONAL)</line>
          <line>key = INSTRUCTION, value = value of type 's', that identifies the instruction to the user</line>
          <line>key = BORDER_CROSSING, value = value of type 's', that contains information about border crossings</line>
          <line>key = TIME_ZONE, value = value of type 'n', that indicates the time zone of the current segment. It is expressed as the time difference from the UTC in minutes</line>
          <line>key = DAYLIGHT_SAVING_TIME, value = value of type 'n', that indicates the daylight saving time of the current segment. It is expressed as the time difference from the UTC in minutes</line>
          <line>key = ADDITIONAL_INFORMATION, value = value of type 's', that contains additional information to the user (toll cost, ... )</line>
          <line>key = HIGHWAY_EXIT, value = value of type 's', that in case the road segment ends with a highway exit, it expresses the highway exit number</line>
          <line>key = START_OFFSET, value = value of type 'u', that indicates the offset of the starting point in meters from the beginning of the route</line>
        </doc>
      </arg>
    </method>
    <method name="GetRouteOverview">
      <doc>
        <line> GetRouteOverview = This method retrieves general information about a given route</line>
      </doc>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="valuesToReturn" type="ai" direction="in">
        <doc>
          <line>valuesToReturn = array[key]</line>
          <line>key = enum(ARRIVAL_TIME,ARRIVAL_DATE,DEPARTURE_TIME,DEPARTURE_DATE,TOTAL_DISTANCE,TOTAL_TIME, ... ,ALL)</line>
        </doc>
      </arg>     
      <arg name="routeOverview" type="a{i(yv)}" direction="out">
        <doc>
          <line>routeOverview = array[detail]</line>
          <line>detail = tuple(key,value)</line>
          <line>key = enum(ARRIVAL_TIME,ARRIVAL_DATE,DEPARTURE_TIME,DEPARTURE_DATE,TOTAL_DISTANCE,TOTAL_TIME, ...)</line>
          <line>key = ARRIVAL_TIME, value of type 'u', that represents the arrival time expressed in seconds since mid-night (UTC)</line>
          <line>key = ARRIVAL_DATE, value of type 'u', that represents the arrival date expressed either as calendar date (the number of days since 1 Jan 2000) or as weekday. The weekday is expressed with values from 0 to 6 (0 = Saturday, 1 = Sunday, 2 = Monday, ..., 6 = Friday)</line>
          <line>key = DEPARTURE_TIME, value of type 'u', that represents the departure time expressed in seconds since mid-night (UTC)</line>
          <line>key = DEPARTURE_DATE, value of type 'u', that represents the departure date expressed either as calendar date (the number of days since 1 Jan 2000) or as weekday. The weekday is expressed with values from 0 to 6  (0 = Saturday, 1 = Sunday, 2 = Monday, ..., 6 = Friday)</line>
          <line>key = TOTAL_DISTANCE, value of type 'u', that represents the total distance in m </line>
          <line>key = TOTAL_TIME, value of type 'u', that represents the total time in seconds </line>
        </doc>
      </arg>
    </method> 
    <method name="GetRouteBoundingBox">
      <doc>
        <line>GetRouteBoundingBox = This method retrieves the bounding box containing a calculated route</line>
      </doc>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="boundingBox" type="((dd)(dd))" direction="out">
        <doc>
          <line>boundingBox = struct(top-left-corner,bottom-right-corner)</line>
          <line>geocoordinates of the top-left-corner = struct(lat,lon)</line>
          <line>geocoordinates of the bottom-right-corner = struct(lat,lon)</line>
          <line>lat = latitude in format %3.6f. Range[-90:+90]. Example: 48.053250</line>
          <line>lon = longitude in format %3.6f. Range[-180:+180]. Example: 8.321000</line>
        </doc>
      </arg>
    </method>
    <method name="GetAllRoutes">
      <doc>
        <line>GetAllRoutes = This method retrieves the handles of all created routes</line>
      </doc>
      <arg name="routesList" type="au" direction="out">
        <doc>
          <line>routesList = array[route]</line>
          <line>route = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
    </method>
    <signal name="AlternativeRoutesAvailable">
      <doc>
        <line>AlternativeRoutesAvailable = This signal is emitted when alternative routes have been computed in the background and are available for guidance.</line>
      </doc>
      <arg name="routeHandlesList" type="au">
        <doc>
          <line>routeHandlesList = array[routeHandle]</line>
          <line>routeHandle = Handle identifying a computed alternative route. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
    </signal>
    <method name="SetBlockedRouteStretches">
      <doc>
        <line>SetBlockedRouteStretches = This method sets blocked streches on a given route</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="blockParameters" type="a(uu)" direction="in">
        <doc>
          <line>blockParameters = struct(offset,length)</line>
          <line>offset = the offset in meters from the beginning of the route where the road block starts from</line>
          <line>length = the length of the road block in meters</line>
          <line>Note: pass an empty array to remove previously set blocked route stretches</line>
        </doc>
      </arg>
    </method>
    <method name="GetBlockedRouteStretches">
      <doc>
        <line>GetBlockedRouteStretches = This method retrieves all blocked streches on a given route</line>
      </doc>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="blockParameters" type="a(uu)" direction="out">
        <doc>
          <line>blockParameters = struct(offset,length)</line>
          <line>offset = the offset in meters from the beginning of the route where the road block starts from</line>
          <line>length = the length of the road block in meters</line>
        </doc>
      </arg>
    </method>
  </interface>
  <interface name="org.genivi.navigationcore.MapMatchedPosition">
    <version>3.0.0 (21-01-2014)</version>
    <doc>
      <line>MapMatchedPosition = This interface offers functions to retrieve the map matched position and to simulate positioning</line>
	  <line></line>
	  <line>If NavigationCore is not in Simulation Mode (Simulation Status is SIMULATION_STATUS_NO_SIMULATION), it is using the EnhancedPosition from the Positioning component.</line>
	  <line>In Simulation Mode it is not using this position, instead it uses FixedPosition or FollowActiveRoute to determine the position.</line>
	  <line>With FixedPosition (Simulation Status is SIMULATION_STATUS_FIXED_POSITION), the position is fixed, unless it is changed by a call to setPosition().</line>
	  <line>This supports use cases like: setting the current car position in a demo mode, or replay a position log file (where setPosition() is called for each logged location).</line>
	  <line>In Follow Active Route mode, NavigationCore is generating positions itself.</line>
	  <line>These positions follow the current active route. When the end of the route is reached, the position jumps back to the starting point of the route.</line>
	  <line>There are two sub states: Running (Simulation Status is SIMULATION_STATUS_RUNNING) and Paused (Simulation Status is SIMULATION_STATUS_PAUSED).</line>
	  <line>By default the ‘driving speed’ will be equal to the free flow speed of each road segment. However a speed factor can be set via the method SetSimulationSpeed.</line>
    </doc>
    <method name="GetVersion">
      <doc>
        <line>GetVersion = This method returns the API version implemented by the server application</line>
      </doc>
      <arg name="version" type="(qqqs)" direction="out">
        <doc>
          <line>version = struct(major,minor,micro,date)</line>
          <line>major = when the major changes, then backward compatibility with previous releases is not granted</line>
          <line>minor = when the minor changes, then backward compatibility with previous releases is granted, but something changed in the implementation of the API (e.g. new methods may have been added)</line>
          <line>micro = when the micro changes, then backward compatibility with previous releases is granted (bug fixes or documentation modifications)</line>
          <line>date = release date (e.g. 21-06-2011)</line>
        </doc>
      </arg>
    </method>
    <method name="SetSimulationMode">
      <doc>
        <line>SetSimulationMode = This method activates or deactivates the simulation mode</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="activate" type="b" direction="in">
        <doc>
          <line>activate = flag. TRUE means that the simulation mode is activated.</line>
		  <line>The simulation status will be SIMULATION_STATUS_FIXED_POSITION, with the position being the last known position in the NavigationCore.</line>
		  <line>FALSE means that the simulation mode is de-activated. The simulation status will be SIMULATION_STATUS_NO_SIMULATION</line>
        </doc>
      </arg>
    </method>
    <method name="GetSimulationStatus">
      <doc>
        <line>GetSimulationStatus = This method retrieves the simulation status</line>
      </doc>
      <arg name="simulationStatus" type="i" direction="out">
        <doc>
          <line>simulationStatus = enum(SIMULATION_STATUS_NO_SIMULATION, SIMULATION_STATUS_RUNNING, SIMULATION_STATUS_PAUSED, SIMULATION_STATUS_FIXED_POSITION)</line>
          <line>SIMULATION_STATUS_NO_SIMULATION means that NavigationCore is using the EnhancedPosition</line>
          <line>SIMULATION_STATUS_RUNNING means that positions are generated along the active route</line>
          <line>SIMULATION_STATUS_PAUSED means that the generation of positions along the active route is paused</line>
          <line>SIMULATION_STATUS_FIXED_POSITION means that the position is fixed.</line>
        </doc>
      </arg>
    </method>
    <method name="AddSimulationStatusListener">
      <doc>
        <line> AddSimulationStatusListener = Add this node as a listener to Simulation Status changes.</line>
		<line>Upon changes a SimulationStatusChanged signal will be received. NavigationCore will only send out a SimulationStatusChanged signal if there is at least one node listening to these changes.</line>
      </doc>
    </method>
    <method name="RemoveSimulationStatusListener">
      <doc>
        <line> RemoveSimulationStatusListener = Remove this node as a listener to Simulation Status changes.</line>
      </doc>
    </method>
    <signal name="SimulationStatusChanged">
      <doc>
        <line>SimulationStatusChanged = This signal is emitted when the Simulation Status has changed</line>
      </doc>
      <arg name="simulationStatus" type="i">
        <doc>
          <line>simulationStatus = enum(SIMULATION_STATUS_NO_SIMULATION, SIMULATION_STATUS_RUNNING, SIMULATION_STATUS_PAUSED, SIMULATION_STATUS_FIXED_POSITION)</line>
          <line>SIMULATION_STATUS_NO_SIMULATION means that NavigationCore is using the EnhancedPosition</line>
          <line>SIMULATION_STATUS_RUNNING means that positions are generated along the active route</line>
          <line>SIMULATION_STATUS_PAUSED means that the generation of positions along the active route is paused</line>
          <line>SIMULATION_STATUS_FIXED_POSITION means that the position is fixed.</line>
        </doc>
      </arg>
    </signal>
    <method name="SetSimulationSpeed">
      <doc>
        <line>SetSimulationSpeed = This method sets the speed factor for the simulation mode</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="speedFactor" type="y" direction="in">
        <doc>
          <line>speedFactor = speed factor</line>
          <line>unit is x0.25. Normal speed x1 is 4</line>
        </doc>
      </arg>
    </method>
    <method name="GetSimulationSpeed">
      <doc>
        <line>GetSimulationSpeed = returns the speed factor for the simulation mode</line>
      </doc>
      <arg name="speedFactor" type="y" direction="out">
        <doc>
          <line>speedFactor = speed factor</line>
          <line>unit is x0.25. Normal speed x1 is 4</line>
        </doc>
      </arg>
    </method>
    <method name="AddSimulationSpeedListener">
      <doc>
        <line> AddSimulationSpeedListener = Add this node as a listener to simulation speed factor changes.</line>
		<line>Upon changes a SimulationSpeedChanged signal will be received.</line>
		<line>NavigationCore will only send out a SimulationSpeedChanged signal if there is at least one node listening to these changes</line>
      </doc>
    </method>
    <method name="RemoveSimulationSpeedListener">
      <doc>
        <line> RemoveSimulationSpeedListener = Remove this node as a listener to simulation speed factor changes.</line>
      </doc>
    </method>
    <signal name="SimulationSpeedChanged">
      <doc>
        <line>SimulationSpeedChanged = This signal is emitted when the simulation speed factor has changed</line>
		<line>NavigationCore will only send out a SimulationSpeedChanged signal if there is at least one node listening to these changes</line>
      </doc>
      <arg name="speedFactor" type="y">
        <doc>
          <line>speedFactor = speed factor</line>
          <line>unit is x0.25. Normal speed x1 is 4</line>
        </doc>
      </arg>
    </signal>
    <method name="StartSimulation">
      <doc>
        <line>StartSimulation = This method starts, or resumes, a Follow Active Route simulation</line>
        <line>If the current Simulation Status is SIMULATION_STATUS_PAUSED, the simulation is resumed from the current location.</line>
		<line>Otherwise the simulation is started from the starting point of the route. In both cases the new status will be SIMULATION_STATUS_RUNNING</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
    </method>
    <method name="PauseSimulation">
      <doc>
        <line>PauseSimulation = This method freezes the current location</line>
		<line>The new status will be SIMULATION_STATUS_PAUSED</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
    </method>
    <method name="GetPosition">
      <doc>
        <line>GetPosition = This method returns the current position</line>
      </doc>
      <arg name="valuesToReturn" type="ai" direction="in">
        <doc>
          <line>valuesToReturn= array[key]</line>
          <line>key = enum(INVALID,TIMESTAMP,LATITUDE,LONGITUDE,ALTITUDE,HEADING,SPEED,CLIMB,GNSS_FIX_STATUS,DR_STATUS,MM_STATUS,SIMULATION_MODE, ... ,ALL)</line>
        </doc>
      </arg>
      <arg name="position" type="a{i(yv)}" direction="out">
        <doc>
          <line>position = dictionary[key,value]</line>
          <line>dictionary = array of tuples (key,value)</line>
          <line>key = enum(INVALID,TIMESTAMP,LATITUDE,LONGITUDE,ALTITUDE,HEADING,SPEED,CLIMB,GNSS_FIX_STATUS,DR_STATUS,MM_STATUS,SIMULATION_MODE, ... )</line>
          <line>key = TIMESTAMP, value = value of type 't', that represents a timestamp in ms</line>
          <line>key = LATITUDE, value = value of type 'd', that expresses the latitude of the current position in format %3.6f. Range [-90,+90]. Example: 48.053250</line>
          <line>key = LONGITUDE, value = value of type 'd', that expresses the longitude of the current position in format %3.6f. Range [-180,+180]. Example: 8.324500</line>
          <line>key = ALTITUDE, value = value of type 'i', that expresses the altitude above the sea level of the current position in meters</line>
          <line>key = HEADING, value = value of type 'u', that expresses the course angle in degree (0 = north, 90 = east, 180 = south, 270 = west, no negative values)</line>
          <line>key = SPEED, value = value of type 'd', that expresses speed measured in m/s. A negative value indicates that the vehicle is moving backwards</line>
          <line>key = CLIMB, value = value of type 'i', that expresses the inclination measured in degrees</line>
          <line>key = GNSS_FIX_STATUS, value = value of type 'q', that represents an enum(INVALID,NO_FIX,TIME_FIX,2D_FIX,3D_FIX, ... )</line>
          <line>key = DR_STATUS, value = value of type 'b', where TRUE means that a dead-reckoning algorithm has been used to calculate the current position</line>
          <line>key = MM_STATUS, value = value of type 'b', where TRUE means that a map-matching algorithm has been used to calculate the current position</line>
          <line>key = SIMULATION_MODE, value = value of type 'b', where TRUE means that the current position is simulated</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.MapMatchedPosition.Error.NoPosition">
        <doc>
          <line>This error is generated if no position is available</line>
        </doc>
      </error>
    </method>
    <method name="SetPosition">
      <doc>
        <line>SetPosition = This method sets the position to a specific location</line>
        <line>Independent of the current Simulation Status, the new status will be SIMULATION_STATUS_FIXED_POSITION.</line>
        <line>This method can be used to replay a position log file (with positions obtained via calls to GetPosition()) by calling this method for each position in the log file.</line>
        <line>It is of course also possible to call this method just once with e.g. a 'current location' entered by the user (via the HMI).</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="position" type="a{i(yv)}" direction="in">
        <doc>
          <line>position = dictionary[key,value]</line>
          <line>dictionary = array of tuples (key,value)</line>
          <line>key = enum(INVALID,TIMESTAMP,LATITUDE,LONGITUDE,ALTITUDE,HEADING,SPEED,CLIMB,GNSS_FIX_STATUS,DR_STATUS,MM_STATUS, ... )</line>
          <line>key = TIMESTAMP, value = value of type 't', that represents a timestamp in ms</line>
          <line>key = LATITUDE, value = value of type 'd', that expresses the latitude of the current position in format %3.6f. Range [-90,+90]. Example: 48.053250</line>
          <line>key = LONGITUDE, value = value of type 'd', that expresses the longitude of the current position in format %3.6f. Range [-180,+180]. Example: 8.324500</line>
          <line>key = ALTITUDE, value = value of type 'i', that expresses the altitude above the sea level of the current position in meters</line>
          <line>key = HEADING, value = value of type 'u', that expresses the course angle in degree (0 = north, 90 = east, 180 = south, 270 = west, no negative values)</line>
          <line>key = SPEED, value = value of type 'd', that expresses speed measured in m/s. A negative value indicates that the vehicle is moving backwards</line>
          <line>key = CLIMB, value = value of type 'i', that expresses the inclination measured in degrees</line>
          <line>key = GNSS_FIX_STATUS, value = value of type 'q', that represents an enum(INVALID,NO_FIX,TIME_FIX,2D_FIX,3D_FIX, ... )</line>
          <line>key = DR_STATUS, value = value of type 'b', where TRUE means that a dead-reckoning algorithm has been used to calculate the current position</line>
          <line>key = MM_STATUS, value = value of type 'b', where TRUE means that a map-matching algorithm has been used to calculate the current position</line>
          <line>Note that the key SIMULATION_MODE is not allowed here, as it will be true by definition.</line>
        </doc>
      </arg>
    </method>
    <signal name="PositionUpdate">
      <doc>
        <line>PositionUpdate = This signal is called to notify a client application of a position change. The update frequency is implementation specific. The maximal allowed frequency is 10Hz</line>
      </doc>
      <arg name="changedValues" type="ai">
        <doc>
          <line>changedValues = array[value]</line>
          <line>value = enum(INVALID,TIMESTAMP,LATITUDE,LONGITUDE,ALTITUDE,HEADING,SPEED,CLIMB,GNSS_FIX_STATUS,DR_STATUS,MM_STATUS,SIMULATION_MODE, ... )</line>
        </doc>
      </arg>
    </signal>
    <method name="GetAddress">
      <doc>
        <line>GetAddress = This method returns the current address</line>
      </doc>
      <arg name="valuesToReturn" type="ai" direction="in">
        <doc>
          <line>valuesToReturn= array[fieldType]</line>
          <line>key = enum(INVALID,TIMESTAMP,COUNTRY,COUNTRYCODE,CITY,STREET,ROAD_NUMBER,HOUSENUMBER,HOUSENAME,CROSSING,DISTRICT,TIMEZONE_OFFSET,DAYLIGHT_OFFSET,MATCH_TYPE, ... ,ALL)</line>
        </doc>
      </arg>
      <arg name="address" type="a{i(yv)}" direction="out">
        <doc>
          <line>address = dictionary[key,value]</line>
          <line>dictionary = array of tuples (key,value)</line>
          <line>key = enum(INVALID,TIMESTAMP,COUNTRY,COUNTRYCODE,CITY,STREET,ROAD_NUMBER,HOUSENUMBER,HOUSENAME,CROSSING,DISTRICT,TIMEZONE_OFFSET,DAYLIGHT_OFFSET,MATCH_TYPE, ... )</line>
          <line>key = TIMESTAMP, value = value of type 't', that represents a timestamp in ms</line>
          <line>key = COUNTRY, value = value of type 's', that identifies the country name</line>
          <line>key = COUNTRYCODE, value = value of type 's', ISO 3166‐1 alpha 3 country code (upper case)</line>
          <line>key = CITY, value = value of type 's', that identifies the city name</line>
          <line>key = STREET, value = value of type 's', that identifies the street name</line>
          <line>key = ROAD_NUMBER, value = value of type ´s´, that identifies the road number</line>
          <line>key = HOUSENUMBER, value = value of type 's', that identifies the house number</line>
          <line>key = HOUSENAME, value = value of type ´s´, that identifies the house name</line>
          <line>key = CROSSING, value = value of type 's', that identifies the crossing</line>
          <line>key = DISTRICT, value = value of type 's', that identifies the district name</line>
          <line>key = TIMEZONE_OFFSET, value = value of type 'n', that identifies the timezone offset at the current address</line>
          <line>key = DAYLIGHT_OFFSET, value = value of type 'n', that identifies the daylight offset at the current address</line>
          <line>key = MATCH_TYPE, value = value of type 'q', that identifies an enum(INVALID,ON_ROAD,OFF_ROAD,ON_FERRY,IN_TUNNEL,ON_CARPARK, ... )</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.MapMatchedPosition.Error.NoMap">
        <doc>
          <line>This error is generated if no map is available</line>
        </doc>
      </error>
      <error name="org.genivi.navigationcore.MapMatchedPosition.Error.OutOfKnownMap">
        <doc>
          <line>This error is generated if the vehicle is located in a position outside of the known map</line>
        </doc>
      </error>
    </method>
    <signal name="AddressUpdate">
      <doc>
        <line>AddressUpdate = This signal is called to notify a client application that the current address changed</line>
      </doc>
      <arg name="changedValues" type="ai">
        <doc>
          <line>changedValues = array[value]</line>
          <line>value = enum(INVALID,TIMESTAMP,COUNTRY,COUNTRYCODE,CITY,STREET,ROAD_NUMBER,HOUSENUMBER,HOUSENAME,CROSSING,DISTRICT,TIMEZONE_OFFSET,DAYLIGHT_OFFSET,MATCH_TYPE, ... )</line>
        </doc>
      </arg>
    </signal>
    <method name="GetPositionOnSegment">
      <doc>
        <line>positionOnSegment = This method returns the vehicle position on a route segment</line>
      </doc>
      <arg name="valuesToReturn" type="ai" direction="in">
        <doc>
          <line>valuesToReturn= array[fieldType]</line>
          <line>key = enum(INVALID,TIMESTAMP,SEGMENT_ID,DIRECTION_ON_SEGMENT,DISTANCE_ON_SEGMENT, ... ,ALL)</line>
        </doc>
      </arg>
      <arg name="positionOnSegment" type="a{i(yv)}" direction="out">
        <doc>
          <line>positionOnSegment = dictionary[key,value]</line>
          <line>dictionary = array of tuples (key,value)</line>
          <line>key = enum(INVALID,TIMESTAMP,SEGMENT_ID,DIRECTION_ON_SEGMENT,DISTANCE_ON_SEGMENT, ... )</line>
          <line>key = TIMESTAMP, value = value of type 't', that represents a timestamp in ms</line>
          <line>key = SEGMENT_ID, value = value = value of type 'ay', that represents a link-ID in a format whose interpretation is left to the navigationcore</line>
          <line>key = DIRECTION_ON_SEGMENT, value = value of type 'b', where TRUE means forward and FALSE means backward</line>
          <line>key = DISTANCE_ON_SEGMENT, value = value of type 'd', that indicates the distance in meter on the segment</line>
        </doc>
      </arg>
    </method>
    <signal name="PositionOnSegmentUpdate">
      <doc>
        <line>PositionOnSegmentUpdate = This signal is called to notify the client that the vehicle position on the route segment changed</line>
      </doc>
      <arg name="changedValues" type="ai">
        <doc>
          <line>changedValues = array[value]</line>
          <line>value = enum(INVALID,TIMESTAMP,SEGMENT_ID,DIRECTION_ON_SEGMENT,DISTANCE_ON_SEGMENT, ... )</line>
        </doc>
      </arg>
    </signal>
    <method name="GetStatus">
      <doc>
        <line>GetStatus = This method returns the current status</line>
      </doc>
      <arg name="valuesToReturn" type="ai" direction="in">
        <doc>
          <line>valuesToReturn = array[fieldType]</line>
          <line>key = enum(INVALID,TIMESTAMP,GNSS_FIX_STATUS,DR_STATUS,MM_STATUS,SIMULATION_MODE, ... ,ALL)</line>
        </doc>
      </arg>
      <arg name="status" type="a{i(yv)}" direction="out">
        <doc>
          <line>status = dictionary[key,value]</line>
          <line>dictionary = array of tuples (key,value)</line>
          <line>key = enum(INVALID,TIMESTAMP,GNSS_FIX_STATUS,DR_STATUS,MM_STATUS,SIMULATION_MODE, ... )</line>
          <line>key = TIMESTAMP, value = value of type 't', that represents a timestamp in ms</line>
          <line>key = GNSS_FIX_STATUS, value = value of type 'q', that represents an enum(INVALID,NO_FIX,TIME_FIX,2D_FIX,3D_FIX, ... )</line>
          <line>key = DR_STATUS, value = value of type 'b', where TRUE means that a dead-reckoning algorithm has been used to calculate the current position</line>
          <line>key = MM_STATUS, value = value of type 'b', where TRUE means that a map-matching algorithm has been used to calculate the current position</line>
          <line>key = SIMULATION_MODE, value = value of type 'b', where TRUE means that the current position is simulated</line>
        </doc>
      </arg>
    </method>
    <signal name="StatusUpdate">
      <doc>
        <line>StatusUpdate = This signal is emitted to notifiy a client application that the current status changed</line>
      </doc>
      <arg name="changedValues" type="ai">
        <doc>
          <line>changedValues = array[value]</line>
          <line>value = enum(INVALID,TIMESTAMP,GNSS_FIX_STATUS,DR_STATUS,MM_STATUS,SIMULATION_MODE, ... )</line>
        </doc>
      </arg>
    </signal>
    <signal name="OffRoadPositionChanged">
      <doc>
        <line>OffroadPositionChanged = This signal is emitted when the heading and the distance to the closest point on the road network changes</line>
      </doc>
      <arg name="distance" type="u">
        <doc>
          <line>distance = distance in meters to the closest point on the road network</line>
        </doc>
      </arg>
      <arg name="direction" type="i">
        <doc>
          <line>direction = direction in degrees relatively to the closest point on the road network. Range [0:360]</line>
        </doc>
      </arg>
    </signal>
  </interface>
  <interface name="org.genivi.navigationcore.Guidance">
    <version>3.1.0 (03-03-2014)</version>
    <doc>
      <line>Guidance = This interface offers functions that implement the route-guidance functionality of a navigation system</line>
    </doc>
    <method name="GetVersion">
      <doc>
        <line>GetVersion = This method returns the API version implemented by the server application</line>
      </doc>
      <arg name="version" type="(qqqs)" direction="out">
        <doc>
          <line>version = struct(major,minor,micro,date)</line>
          <line>major = when the major changes, then backward compatibility with previous releases is not granted</line>
          <line>minor = when the minor changes, then backward compatibility with previous releases is granted, but something changed in the implementation of the API (e.g. new methods may have been added)</line>
          <line>micro = when the micro changes, then backward compatibility with previous releases is granted (bug fixes or documentation modifications)</line>
          <line>date = release date (e.g. 21-06-2011)</line>
        </doc>
      </arg>
    </method>
    <method name="StartGuidance">
      <doc>
        <line>StartGuidance = This method starts the guidance for a given route</line>
		<line>The guidanceStatus will change to ACTIVE</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="in">
        <doc>
          <line>routeHandle = Route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
    </method>
    <method name="StopGuidance">
      <doc>
        <line>StopGuidance = This method stops the guidance</line>
		<line>The guidanceStatus will change to INACTIVE</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
    </method>
    <method name="SetVoiceGuidance">
      <doc>
        <line>SetVoiceGuidance = This method switch on/off the voice guidance</line>
      </doc>
      <arg name="activate" type="b" direction="in">
        <doc>
          <line>activation of the voice guidance</line>
        </doc>
      </arg>
      <arg name="voice" type="s" direction="in">
        <doc>
          <line>kind of voice (to be defined)</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Guidance.Error.VoiceNotAllowed">
        <doc>
          <line>This error is generated if the voice generation is inactive </line>
        </doc>
      </error>
    </method>
    <method name="GetGuidanceDetails">
      <doc>
        <line>GetGuidanceDetails = This method retrieves guidance information </line>
      </doc>
      <arg name="voiceGuidance" type="b" direction="out">
        <doc>
          <line>voiceGuidance = if TRUE voice guidance is active</line>
        </doc>
      </arg>
      <arg name="vehicleOnTheRoad" type="b" direction="out">
        <doc>
          <line>vehicleOnTheRoad = if TRUE the vehicle is located on the road network</line>
        </doc>
      </arg>
      <arg name="isDestinationReached" type="b" direction="out">
        <doc>
          <line>isDestinationReached = if TRUE the destination has been reached</line>
        </doc>
      </arg>
      <arg name="maneuver" type="i" direction="out">
        <doc>
          <line>maneuver = enum(INVALID,CRUISE,MANEUVER_APPEARED,PRE_ADVICE,ADVICE,PASSED, ... )</line>
        </doc>
      </arg>
    </method>
    <method name="PlayVoiceManeuver">
      <doc>
        <line>PlayVoiceManeuver = This method plays or repeats the last voice guidance</line>
      </doc>
      <error name="org.genivi.navigationcore.Guidance.Error.VoiceNotAllowed">
        <doc>
          <line>This error is generated if the voice generation is inactive </line>
        </doc>
      </error>
    </method>
    <method name="GetWaypointInformation">
      <doc>
        <line>GetWaypointInformation = This method retrieves the information on the remaining way points of the route. A point can be the final destination as well as a stage defined by the user. The returned waypoints are ordered by their 'number'.</line>
      </doc>
      <arg name="requestedNumberOfWaypoints" type="q" direction="in">
        <doc>
          <line>requestedNumberOfWaypoints = the number of requested waypoints. If 0, all waypoints will be returned.</line>
        </doc>
      </arg>
      <arg name="numberOfWaypoints" type="q" direction="out">
        <doc>
          <line>numberOfWaypoints = the number of retrieved waypoints(NOTE: the number corresponds to the number of elements in the array)</line>
        </doc>
      </arg>
      <arg name="waypointsList" type="a(uuiinnbq)" direction="out">
        <doc>
          <line>array[struct(waypointOffset,travelTime,direction,side,timeZone,daylightSavingTime,isDestination,number)]</line>
          <line>waypointOffset = the offset of the way point in meters from the beginning of the route</line>
          <line>travelTime = time to reach the way point in seconds</line>
          <line>direction = direction of the way point in degree relatively to the North. Range [0:360]</line>
          <line>side = enum(LEFT,RIGHT,NOT_AVAILABLE)</line>
          <line>timeZone = time zone of the way point. It is expressed as the time difference from the UTC in minutes</line>
          <line>daylightSavingTime = daylight saving time of the way point. It is expressed as the time difference from the UTC in minutes</line>
          <line>isDestination = if TRUE the way point is the destination</line>
          <line>number = number of the next waypoint (related to the waypoint list, first way point index is 0)</line>
        </doc>
      </arg>
    </method>
    <method name="GetDestinationInformation">
      <doc>
        <line>This method retrieves the information on the final destination</line>
      </doc>
      <arg name="offset" type="u" direction="out">
        <doc>
          <line>offset = offset of the destination in meter from the beginning of the route</line>
        </doc>
      </arg>
      <arg name="travelTime" type="u" direction="out">
        <doc>
          <line>travelTime = time to reach the destination in second</line>
        </doc>
      </arg>
      <arg name="direction" type="i" direction="out">
        <doc>
          <line>direction = direction of the destination in degree relatively to the North. Range [0:360]</line>
        </doc>
      </arg>
      <arg name="side" type="i" direction="out">
        <doc>
          <line>side = enum(LEFT,RIGHT,NOT_AVAILABLE)</line>
        </doc>
      </arg>
      <arg name="timeZone" type="n" direction="out">
        <doc>
          <line>timeZone = time zone of the destination. It is expressed as the time difference from the UTC in minutes</line>
        </doc>
      </arg>
      <arg name="daylightSavingTime" type="n" direction="out">
        <doc>
          <line>daylightSavingTime = daylight saving time of the destination. It is expressed as the time difference from the UTC in minutes</line>
        </doc>
      </arg>
    </method>
    <signal name="VehicleLeftTheRoadNetwork">
      <doc>
        <line>VehicleLeftTheRoadNetwork = This signal is emitted when the vehicle exits from the road network</line>
      </doc>
    </signal>
    <signal name="GuidanceStatusChanged">
      <doc>
        <line>GuidanceStatusChanged = This signal is emitted when the guidance status changes</line>
      </doc>
      <arg name="guidanceStatus" type="i">
        <doc>
          <line>guidanceStatus = enum(INVALID,ACTIVE,INACTIVE)</line>
          <line>ACTIVE means that NavigationCore is providing guidance information</line>
          <line>INACTIVE means that NavigationCore is not providing guidance information</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u">
        <doc>
          <line>routeHandle = Active route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value. Should be ignored when guidanceStatus=INACTIVE.</line>
        </doc>
      </arg>
    </signal>
    <signal name="WaypointReached">
      <doc>
        <line>WaypointReached = This signal is emitted when the destination is reached</line>
      </doc>
      <arg name="isDestination" type="b">
        <doc>
          <line>isDestination = flag. TRUE means that the way point is the destination</line>
        </doc>
      </arg>
    </signal>
    <signal name="ManeuverChanged">
      <doc>
        <line>This signal is emitted each time a maneuver event is going</line>
      </doc>
      <arg name="maneuver" type="i">
        <doc>
          <line>maneuver = enum(INVALID,CRUISE,MANEUVER_APPEARED,PRE_ADVICE,ADVICE,PASSED, ... )</line>
        </doc>
      </arg>
    </signal>
    <signal name="PositionOnRouteChanged">
      <doc>
        <line>PositionOnRouteChanged = This signal is emitted when the position on the route changes</line>
      </doc>
      <arg name="offsetOnRoute" type="u">
        <doc>
          <line>offsetOnRoute = the current offset on the route in meters from the beginning of the route</line>
        </doc>
      </arg>
    </signal>
    <method name="GetManeuversList">
      <doc>
        <line>GetManeuversList = This method retrieves the list of next maneuvers</line>
      </doc>
      <arg name="requestedNumberOfManeuvers" type="q" direction="in">
        <doc>
          <line>requestedNumberOfManeuvers = the number of requested maneuvers</line>
        </doc>
      </arg>
      <arg name="maneuverOffset" type="u" direction="in">
        <doc>
          <line>maneuverOffset = the offset of the first maneuver to retrieve</line>
        </doc>
      </arg>
      <arg name="numberOfManeuvers" type="q" direction="out">
        <doc>
          <line>numberOfManeuvers = the number of retrieved maneuvers</line>
          <line>Note: the number corresponds to the number of elements in the array</line>
        </doc>
      </arg>
      <arg name="maneuversList" type="a(ssqiua(uuiia{i(yv)}))" direction="out">
        <doc>
          <line>maneuversList = array[struct(roadNumberAfterManeuver,roadNameAfterManeuver,roadPropertyAfterManeuver,drivingSide,offsetOfNextManeuver,maneuverDetails)]</line>
          <line>roadNumberAfterManeuver = the number of the road after the maneuver (if a road has multiple road numbers, they will be separated by slashes ('/') and combined into one string)</line>
          <line>roadNameAfterManeuver = the name of the road after the maneuver</line>
          <line>roadPropertyAfterManeuver = enum(TOLL_ROADS, ... ,DEFAULT)</line>
          <line>drivingSide = enum(LEFT,RIGHT)</line>
          <line>offsetOfNextManeuver = the offset of the next maneuver in meters from the beginning of the route (next maneuver is the second maneuver on the route ahead)</line>
          <line>maneuverDetails = array[struct(offsetOfManeuver,travelTime,direction,maneuver,maneuverData)]</line>
          <line>offsetOfManeuver = the offset of the current maneuver in meters from the beginning of the route (current maneuver is the first maneuver on the route ahead)</line>
          <line>travelTime = travel time to the basic maneuver in seconds</line>
          <line>direction = direction of the maneuver in degree relatively to the North. Range [0:360]</line>
          <line>maneuver = enum(INVALID,STRAIGHT_ON,TURN,CROSSROAD,ROUNDABOUT,HIGHWAY_ENTER,HIGHWAY_EXIT,BIFURCATION,FOLLOW_SPECIFIC_LANE,DESTINATION,WAYPOINT,ROAD_FORM_CHANGE)</line>
          <line>maneuverData = array[struct(key, value)]</line>
          <line>key = enum(LENGTH,DIRECTION,EXIT_NUMBER,ROAD_FORM,LANE_INFO,LATITUDE,LONGITUDE,ALTITUDE)</line>
          <line>key = LENGTH, value of type 'q', when maneuver=ROUNDABOUT, expresses the length of the route segment between the entry to and the exit from the roundabout</line>
          <line>key = DIRECTION, value of type 'q', enum(INVALID,STRAIGHT_ON,LEFT,SLIGHT_LEFT,HARD_LEFT,RIGHT,SLIGHT_RIGHT,HARD_RIGHT,UTURN_RIGHT,UTURN_LEFT)</line>
          <line>key = EXIT_NUMBER, when maneuver=ROUNDABOUT, value of type 'q' that expresses the roundabout exit number</line>
          <line>                   when maneuver=HIGHWAY_EXIT, value of type 's' that expresses the highway exit number</line>
          <line>key = ROAD_FORM, value of type 'q', enum(INVALID,ROAD_REGULAR,ROAD_HIGHWAY_MOTORWAY,ROAD_FERRY)</line>
          <line>key = LANE_INFO, value of type 'a(uuuq)', array[struct(laneIndex,laneDirections,directionToFollow,divider)]</line>
          <line>laneIndex = number of the individual lane. Counting starts from zero, beginning at the left-most lane in the direction of travel (independent of the driving side)</line>
          <line>laneDirections = bitfield where each bit corresponds to a certain direction. A 1-bit indicates that the corresponding part of the lane arrow is drawn in the lane information on the street (see the lane info bitmasks)</line>
          <line>directionToFollow = bitfield where each bit corresponds to a certain direction. A 1-bit indicates that the corresponding part of the lane arrow matches the direction of the corresponding maneuver (see the lane info bitmasks). At most one bit of this bitmask will be set.</line>
          <line>The bitmasks are: LANE_INFO_BITMASK_STRAIGHT,LANE_INFO_BITMASK_SLIGHTRIGHT,LANE_INFO_BITMASK_RIGHT,LANE_INFO_BITMASK_SHARPRIGHT,LANE_INFO_BITMASK_RIGHTUTURN,LANE_INFO_BITMASK_SLIGHTLEFT,LANE_INFO_BITMASK_LEFT,LANE_INFO_BITMASK_SHARPLEFT,LANE_INFO_BITMASK_LEFTUTURN</line>
          <line>divider = indicates the type of divider between the given lane and the next one to the right, in the direction of travel</line>
          <line>          enum(DIVIDER_UNDEFINED,DIVIDER_INTERRUPTEDLONG,DIVIDER_INTERRUPTEDSHORT,DIVIDER_SOLIDSINGLE,DIVIDER_SOLIDDOUBLE,DIVIDER_SOLIDINTERRUPTED,DIVIDER_INTERRUPTEDSOLID)</line>
          <line>Note: To describe the divider on the left side of the left-most lane, use the following entry in LANE_INFO: (laneIndex=0xffffffff,laneDirections=0x00000000,directionToFollow=0x00000000,divider=type)</line>
          <line>key = LATITUDE, value = value of type 'd', that expresses the latitude of the starting point in format %3.6f. Range [-90:+90]. Example: 48.053250</line>
          <line>key = LONGITUDE, value = value of type 'd', that expresses the longitude of the starting point in format %3.6f. Range [-180:+180]. Example: 8.324500</line>
          <line>key = ALTITUDE, value = value of type 'i', that expresses the altitude of the starting point in meters</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Guidance.Error.NoManeuver">
        <doc>
          <line>This error is generated in case there's no maneuver until the destination</line>
        </doc>
      </error>
    </method>
    <signal name="VehicleLeftTheRoute">
      <doc>
        <line>VehicleLeftTheRoute = This signal is emitted when the vehicle has left the route</line>
      </doc>
    </signal>
    <method name="SetRouteCalculationMode">
      <doc>
        <line>SetRouteCalculationMode = This method configures the way the navigation application wants the navigation core to behave of reroute trigger</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <arg name="routeCalculationMode" type="i" direction="in">
        <doc>
          <line>routeCalculationMode = enum(INVALID,ALL_MANUAL,ALL_AUTOMATIC,TRAFFIC_MANUAL,OFF_ROUTE_MANUAL)</line>
        </doc>
      </arg>
    </method>
    <method name="SkipNextManeuver">
      <doc>
        <line>SkipNextManeuver = This method allows to jump behind the current maneuver</line>
      </doc>
      <arg name="sessionHandle" type="u" direction="in">
        <doc>
          <line>sessionHandle = Session handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value</line>
        </doc>
      </arg>
      <error name="org.genivi.navigationcore.Guidance.Error.NoManeuver">
        <doc>
          <line>This error is generated in case there's no maneuver until the destination</line>
        </doc>
      </error>
    </method>
    <method name="GetGuidanceStatus">
      <doc>
        <line>GetGuidanceStatus = This method retrieves the guidance status</line>
      </doc>
      <arg name="guidanceStatus" type="i" direction="out">
        <doc>
          <line>guidanceStatus = enum(INVALID,ACTIVE,INACTIVE)</line>
          <line>ACTIVE means that NavigationCore is providing guidance information</line>
          <line>INACTIVE means that NavigationCore is not providing guidance information</line>
        </doc>
      </arg>
      <arg name="routeHandle" type="u" direction="out">
        <doc>
          <line>routeHandle = Active route handle. Range[0x0:0x7fffffff]. 0x0 is reserved as an invalid handle value. Should be ignored when guidanceStatus=INACTIVE</line>
        </doc>
      </arg>
    </method>
    <method name="SetVoiceGuidanceSettings">
      <doc>
        <line>SetVoiceGuidanceSettings = This method sets the voice guidance settings</line>
      </doc>
      <arg name="promptMode" type="i" direction="in">
        <doc>
          <line>mode = enum(INVALID,DISABLED_PROMPT,AUTOMATIC_PROMPT,MANUAL_PROMPT, ... )</line>
          <line>MANUAL_PROMPT means that a client application can ask the NavigationCore to play the voice prompts</line>
          <line>AUTOMATIC_PROMPT means that the voice prompts will be requested by NavigationCore automatically</line>
          <line>DISABLED_PROMPT means that the client application will the voice generator component directly to play the messages (bypassing the NavigationCore)</line>
        </doc>
      </arg>
    </method>
    <method name="GetVoiceGuidanceSettings">
      <doc>
        <line>GetVoiceGuidanceSettings = This method returns the used voice guidance settings</line>
      </doc>
      <arg name="promptMode" type="i" direction="out">
        <doc>
          <line>mode = enum(INVALID,DISABLED_PROMPT,AUTOMATIC_PROMPT,MANUAL_PROMPT, ... )</line>
          <line>MANUAL_PROMPT means that a client application can ask the NavigationCore to play the voice prompts</line>
          <line>AUTOMATIC_PROMPT means that the voice prompts will be requested by NavigationCore automatically</line>
          <line>DISABLED_PROMPT means that the client application will the voice generator component directly to play the messages (bypassing the NavigationCore)</line>
        </doc>
      </arg>
    </method>
    <signal name="PositionToRouteChanged">
      <doc>
        <line>PositionToRouteChanged = This signal is emitted when the vehicle is off-the-road network and either the heading or the distance (or both) to the closest point on the active route changes</line>
      </doc>
      <arg name="distance" type="u">
        <doc>
          <line>distance = distance in meters to the closest point on the active route</line>
        </doc>
      </arg>
      <arg name="direction" type="i">
        <doc>
          <line>direction = direction in degrees relatively to the closest point on the active route. Range [0:360]</line>
        </doc>
      </arg>
    </signal>
    <signal name="ActiveRouteChanged">
      <doc>
        <line>ActiveRouteChanged = This signal is emitted when the active route changes</line>
      </doc>
      <arg name="changeCause" type="i">
        <doc>
          <line>changeCause = enum(INVALID,TRAFFIC,OFF_ROUTE,MANUAL,...)</line>
        </doc>
      </arg>
    </signal>
  </interface>
</node>
