/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201608040617.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: This interface offers functions that implement the routing functionality of a
 *   navigation system
 */
#ifndef V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_Routing_PROXY_HPP_
#define V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_Routing_PROXY_HPP_

#include <v4/org/genivi/navigation/navigationcore/RoutingProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v4 {
namespace org {
namespace genivi {
namespace navigation {
namespace navigationcore {

template <typename ... _AttributeExtensions>
class RoutingProxy
    : virtual public Routing, 
      virtual public RoutingProxyBase,
      virtual public _AttributeExtensions... {
public:
    RoutingProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~RoutingProxy();

    typedef Routing InterfaceType;



    /**
     * description: routeDeleted = This signal is emitted to inform clients that the current route
     *   has been deleted
     */
    /**
     * Returns the wrapper class that provides access to the broadcast routeDeleted.
     */
    virtual RouteDeletedEvent& getRouteDeletedEvent() {
        return delegate_->getRouteDeletedEvent();
    }
    /**
     * description: routeCalculationCancelled = This signal informs a client that a route
     *   calculation was cancelled
     */
    /**
     * Returns the wrapper class that provides access to the broadcast routeCalculationCancelled.
     */
    virtual RouteCalculationCancelledEvent& getRouteCalculationCancelledEvent() {
        return delegate_->getRouteCalculationCancelledEvent();
    }
    /**
     * description: routeCalculationSuccessful = This signal informs a client that a route
     *   calculation was successful
     */
    /**
     * Returns the wrapper class that provides access to the broadcast routeCalculationSuccessful.
     */
    virtual RouteCalculationSuccessfulEvent& getRouteCalculationSuccessfulEvent() {
        return delegate_->getRouteCalculationSuccessfulEvent();
    }
    /**
     * description: routeCalculationFailed = This signal informs a client that a route calculation
     *   failed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast routeCalculationFailed.
     */
    virtual RouteCalculationFailedEvent& getRouteCalculationFailedEvent() {
        return delegate_->getRouteCalculationFailedEvent();
    }
    /**
     * description: routeCalculationProgressUpdate = This signal informs a client about a route
     *   calculation progress
     */
    /**
     * Returns the wrapper class that provides access to the broadcast routeCalculationProgressUpdate.
     */
    virtual RouteCalculationProgressUpdateEvent& getRouteCalculationProgressUpdateEvent() {
        return delegate_->getRouteCalculationProgressUpdateEvent();
    }
    /**
     * description: alternativeRoutesAvailable = This signal is emitted when alternative routes
     *   have been computed in the background and are available for guidance.
     */
    /**
     * Returns the wrapper class that provides access to the broadcast alternativeRoutesAvailable.
     */
    virtual AlternativeRoutesAvailableEvent& getAlternativeRoutesAvailableEvent() {
        return delegate_->getAlternativeRoutesAvailableEvent();
    }

    /**
     * description: This method returns the API version implemented by the server application
     * Calls getVersion with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getVersion(CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::CommonTypes::Version &_version, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getVersion with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getVersionAsync(GetVersionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method creates a route
     * Calls createRoute with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void createRoute(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls createRoute with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> createRouteAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CreateRouteAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method deletes a route and its associated resources
     * Calls deleteRoute with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void deleteRoute(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls deleteRoute with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> deleteRouteAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, DeleteRouteAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method sets the cost model
     * Calls setCostModel with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setCostModel(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::CostModel &_costModel, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setCostModel with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setCostModelAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::CostModel &_costModel, SetCostModelAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method retrieves the selected cost model
     * Calls getCostModel with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getCostModel(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, Routing::CostModel &_costModel, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCostModel with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getCostModelAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetCostModelAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method retrieves a list of supported cost models
     * Calls getSupportedCostModels with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSupportedCostModels(CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::CostModel> &_costModelsList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedCostModels with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSupportedCostModelsAsync(GetSupportedCostModelsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method sets a list of route preferences
     * Calls setRoutePreferences with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setRoutePreferences(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, const std::vector<Routing::RoutePreference> &_roadPreferenceList, const std::vector<Routing::ConditionPreference> &_conditionPreferenceList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setRoutePreferences with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setRoutePreferencesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, const std::vector<Routing::RoutePreference> &_roadPreferenceList, const std::vector<Routing::ConditionPreference> &_conditionPreferenceList, SetRoutePreferencesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method retrieves a list of selected route preferences
     * Calls getRoutePreferences with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getRoutePreferences(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::RoutePreference> &_roadPreferenceList, std::vector<Routing::ConditionPreference> &_conditionPreferenceList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getRoutePreferences with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getRoutePreferencesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, GetRoutePreferencesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method retrieves a list of supported route preferences
     * Calls getSupportedRoutePreferences with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSupportedRoutePreferences(CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::RoutePreference> &_routePreferencesList, std::vector<Routing::ConditionPreference> &_conditionPreferenceList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedRoutePreferences with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSupportedRoutePreferencesAsync(GetSupportedRoutePreferencesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method sets the time schedule for the route to be calculated
     * Calls setRouteSchedule with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setRouteSchedule(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::RouteSchedule &_routeSchedule, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setRouteSchedule with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setRouteScheduleAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::RouteSchedule &_routeSchedule, SetRouteScheduleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method gets the time schedule for the route to be calculated
     * Calls getRouteSchedule with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getRouteSchedule(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::Schedule> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, Routing::RouteSchedule &_routeSchedule, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getRouteSchedule with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getRouteScheduleAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::Schedule> &_valuesToReturn, GetRouteScheduleAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: This method sets a list of means of transportation that must be considered when
     *   calculating a route
     * Calls setTransportationMeans with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setTransportationMeans(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::TransportationMeans> &_transportationMeansList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setTransportationMeans with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setTransportationMeansAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::TransportationMeans> &_transportationMeansList, SetTransportationMeansAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getTransportationMeans = This method retrieves the selected means of
     *   transportation
     * Calls getTransportationMeans with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getTransportationMeans(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::TransportationMeans> &_transportationMeansList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getTransportationMeans with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getTransportationMeansAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetTransportationMeansAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getSupportedTransportationMeans = This method retrieves a list of supported
     *   means of transportation
     * Calls getSupportedTransportationMeans with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSupportedTransportationMeans(CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::TransportationMeans> &_transportationMeansList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSupportedTransportationMeans with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSupportedTransportationMeansAsync(GetSupportedTransportationMeansAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setExcludedAreas = This method sets the areas to be excluded when calculating a
     *   route
     * Calls setExcludedAreas with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setExcludedAreas(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon> &_excludedAreas, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setExcludedAreas with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setExcludedAreasAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon> &_excludedAreas, SetExcludedAreasAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getExcludedAreas = This method retrieves the areas to be excluded when
     *   calculating a route
     * Calls getExcludedAreas with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getExcludedAreas(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon> &_excludedAreas, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getExcludedAreas with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getExcludedAreasAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetExcludedAreasAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setWaypoints = This method sets a list of waypoints
     * Calls setWaypoints with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setWaypoints(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const bool &_startFromCurrentPosition, const std::vector<Routing::WayPoint> &_waypointsList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setWaypoints with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setWaypointsAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const bool &_startFromCurrentPosition, const std::vector<Routing::WayPoint> &_waypointsList, SetWaypointsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getWaypoints = This method retrieves a list of waypoints
     * Calls getWaypoints with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getWaypoints(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, bool &_startFromCurrentPosition, std::vector<Routing::WayPoint> &_waypointsList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getWaypoints with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getWaypointsAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetWaypointsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: calculateRoute = This method starts a route calculation
     * Calls calculateRoute with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void calculateRoute(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls calculateRoute with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> calculateRouteAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CalculateRouteAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: cancelRouteCalculation = This method cancels a route calculation
     * Calls cancelRouteCalculation with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void cancelRouteCalculation(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls cancelRouteCalculation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> cancelRouteCalculationAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CancelRouteCalculationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: calculateRoutes = This method allows a client to calculate alternative routes
     *   that differs from a list of already calculated routes
     * Calls calculateRoutes with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void calculateRoutes(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_calculatedRoutesList, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_alternativeRoutesList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls calculateRoutes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> calculateRoutesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_calculatedRoutesList, CalculateRoutesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getRouteSegments = This method retrieves a list of segments for a given route
     *   starting from the one closest to the current position to the one closest to
     *   the destination
     * Calls getRouteSegments with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getRouteSegments(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const int16_t &_detailLevel, const std::vector<Routing::RouteSegmentType> &_valuesToReturn, const uint32_t &_numberOfSegments, const uint32_t &_offset, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_totalNumberOfSegments, std::vector<Routing::RouteSegment> &_routeSegments, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getRouteSegments with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getRouteSegmentsAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const int16_t &_detailLevel, const std::vector<Routing::RouteSegmentType> &_valuesToReturn, const uint32_t &_numberOfSegments, const uint32_t &_offset, GetRouteSegmentsAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getRouteOverview = This method retrieves general information about a given route
     * Calls getRouteOverview with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getRouteOverview(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::RouteOverviewType> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, Routing::RouteOverview &_routeOverview, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getRouteOverview with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getRouteOverviewAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::RouteOverviewType> &_valuesToReturn, GetRouteOverviewAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getRouteBoundingBox = This method retrieves the bounding box containing a
     *   calculated route
     * Calls getRouteBoundingBox with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getRouteBoundingBox(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::navigation::NavigationTypes::Rectangle &_boundingBox, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getRouteBoundingBox with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getRouteBoundingBoxAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetRouteBoundingBoxAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getAllRoutes = This method retrieves the handles of all created routes
     * Calls getAllRoutes with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getAllRoutes(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_routesList, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getAllRoutes with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getAllRoutesAsync(GetAllRoutesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setBlockedRouteStretches = This method sets blocked streches on a given route
     * Calls setBlockedRouteStretches with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setBlockedRouteStretches(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::BlockedRouteElement> &_blockParameters, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setBlockedRouteStretches with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setBlockedRouteStretchesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::BlockedRouteElement> &_blockParameters, SetBlockedRouteStretchesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getBlockedRouteStretches = This method retrieves all blocked streches on a
     *   given route
     * Calls getBlockedRouteStretches with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getBlockedRouteStretches(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::BlockedRouteElement> &_blockParameters, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getBlockedRouteStretches with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getBlockedRouteStretchesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetBlockedRouteStretchesAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<RoutingProxyBase> delegate_;
};

typedef RoutingProxy<> RoutingProxyDefault;


//
// RoutingProxy Implementation
//
template <typename ... _AttributeExtensions>
RoutingProxy<_AttributeExtensions...>::RoutingProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<RoutingProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<RoutingProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
RoutingProxy<_AttributeExtensions...>::~RoutingProxy() {
}

/**
 * description: This method returns the API version implemented by the server application
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getVersion(CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::CommonTypes::Version &_version, const CommonAPI::CallInfo *_info) {
    delegate_->getVersion(_internalCallStatus, _version, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getVersionAsync(GetVersionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getVersionAsync(_callback, _info);
}
/**
 * description: This method creates a route
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::createRoute(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const CommonAPI::CallInfo *_info) {
    delegate_->createRoute(_sessionHandle, _internalCallStatus, _routeHandle, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::createRouteAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CreateRouteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->createRouteAsync(_sessionHandle, _callback, _info);
}
/**
 * description: This method deletes a route and its associated resources
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::deleteRoute(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->deleteRoute(_sessionHandle, _routeHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::deleteRouteAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, DeleteRouteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->deleteRouteAsync(_sessionHandle, _routeHandle, _callback, _info);
}
/**
 * description: This method sets the cost model
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::setCostModel(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::CostModel &_costModel, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    if (!_costModel.validate()) {
        _internalCallStatus = CommonAPI::CallStatus::INVALID_VALUE;
        return;
    }
    delegate_->setCostModel(_sessionHandle, _routeHandle, _costModel, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::setCostModelAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::CostModel &_costModel, SetCostModelAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    if (!_costModel.validate()) {
        _callback(CommonAPI::CallStatus::INVALID_VALUE);
        std::promise<CommonAPI::CallStatus> promise;
        promise.set_value(CommonAPI::CallStatus::INVALID_VALUE);
        return promise.get_future();
    }
    return delegate_->setCostModelAsync(_sessionHandle, _routeHandle, _costModel, _callback, _info);
}
/**
 * description: This method retrieves the selected cost model
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getCostModel(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, Routing::CostModel &_costModel, const CommonAPI::CallInfo *_info) {
    delegate_->getCostModel(_routeHandle, _internalCallStatus, _costModel, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getCostModelAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetCostModelAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getCostModelAsync(_routeHandle, _callback, _info);
}
/**
 * description: This method retrieves a list of supported cost models
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getSupportedCostModels(CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::CostModel> &_costModelsList, const CommonAPI::CallInfo *_info) {
    delegate_->getSupportedCostModels(_internalCallStatus, _costModelsList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getSupportedCostModelsAsync(GetSupportedCostModelsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSupportedCostModelsAsync(_callback, _info);
}
/**
 * description: This method sets a list of route preferences
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::setRoutePreferences(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, const std::vector<Routing::RoutePreference> &_roadPreferenceList, const std::vector<Routing::ConditionPreference> &_conditionPreferenceList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setRoutePreferences(_sessionHandle, _routeHandle, _countryCode, _roadPreferenceList, _conditionPreferenceList, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::setRoutePreferencesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, const std::vector<Routing::RoutePreference> &_roadPreferenceList, const std::vector<Routing::ConditionPreference> &_conditionPreferenceList, SetRoutePreferencesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setRoutePreferencesAsync(_sessionHandle, _routeHandle, _countryCode, _roadPreferenceList, _conditionPreferenceList, _callback, _info);
}
/**
 * description: This method retrieves a list of selected route preferences
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getRoutePreferences(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::RoutePreference> &_roadPreferenceList, std::vector<Routing::ConditionPreference> &_conditionPreferenceList, const CommonAPI::CallInfo *_info) {
    delegate_->getRoutePreferences(_routeHandle, _countryCode, _internalCallStatus, _roadPreferenceList, _conditionPreferenceList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getRoutePreferencesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, GetRoutePreferencesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getRoutePreferencesAsync(_routeHandle, _countryCode, _callback, _info);
}
/**
 * description: This method retrieves a list of supported route preferences
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getSupportedRoutePreferences(CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::RoutePreference> &_routePreferencesList, std::vector<Routing::ConditionPreference> &_conditionPreferenceList, const CommonAPI::CallInfo *_info) {
    delegate_->getSupportedRoutePreferences(_internalCallStatus, _routePreferencesList, _conditionPreferenceList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getSupportedRoutePreferencesAsync(GetSupportedRoutePreferencesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSupportedRoutePreferencesAsync(_callback, _info);
}
/**
 * description: This method sets the time schedule for the route to be calculated
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::setRouteSchedule(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::RouteSchedule &_routeSchedule, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setRouteSchedule(_sessionHandle, _routeHandle, _routeSchedule, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::setRouteScheduleAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::RouteSchedule &_routeSchedule, SetRouteScheduleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setRouteScheduleAsync(_sessionHandle, _routeHandle, _routeSchedule, _callback, _info);
}
/**
 * description: This method gets the time schedule for the route to be calculated
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getRouteSchedule(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::Schedule> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, Routing::RouteSchedule &_routeSchedule, const CommonAPI::CallInfo *_info) {
    delegate_->getRouteSchedule(_routeHandle, _valuesToReturn, _internalCallStatus, _routeSchedule, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getRouteScheduleAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::Schedule> &_valuesToReturn, GetRouteScheduleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getRouteScheduleAsync(_routeHandle, _valuesToReturn, _callback, _info);
}
/**
 * description: This method sets a list of means of transportation that must be considered when
 *   calculating a route
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::setTransportationMeans(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::TransportationMeans> &_transportationMeansList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setTransportationMeans(_sessionHandle, _routeHandle, _transportationMeansList, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::setTransportationMeansAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::TransportationMeans> &_transportationMeansList, SetTransportationMeansAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setTransportationMeansAsync(_sessionHandle, _routeHandle, _transportationMeansList, _callback, _info);
}
/**
 * description: getTransportationMeans = This method retrieves the selected means of
 *   transportation
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getTransportationMeans(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::TransportationMeans> &_transportationMeansList, const CommonAPI::CallInfo *_info) {
    delegate_->getTransportationMeans(_routeHandle, _internalCallStatus, _transportationMeansList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getTransportationMeansAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetTransportationMeansAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getTransportationMeansAsync(_routeHandle, _callback, _info);
}
/**
 * description: getSupportedTransportationMeans = This method retrieves a list of supported
 *   means of transportation
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getSupportedTransportationMeans(CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::TransportationMeans> &_transportationMeansList, const CommonAPI::CallInfo *_info) {
    delegate_->getSupportedTransportationMeans(_internalCallStatus, _transportationMeansList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getSupportedTransportationMeansAsync(GetSupportedTransportationMeansAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSupportedTransportationMeansAsync(_callback, _info);
}
/**
 * description: setExcludedAreas = This method sets the areas to be excluded when calculating a
 *   route
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::setExcludedAreas(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon> &_excludedAreas, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setExcludedAreas(_sessionHandle, _routeHandle, _excludedAreas, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::setExcludedAreasAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon> &_excludedAreas, SetExcludedAreasAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setExcludedAreasAsync(_sessionHandle, _routeHandle, _excludedAreas, _callback, _info);
}
/**
 * description: getExcludedAreas = This method retrieves the areas to be excluded when
 *   calculating a route
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getExcludedAreas(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon> &_excludedAreas, const CommonAPI::CallInfo *_info) {
    delegate_->getExcludedAreas(_routeHandle, _internalCallStatus, _excludedAreas, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getExcludedAreasAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetExcludedAreasAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getExcludedAreasAsync(_routeHandle, _callback, _info);
}
/**
 * description: setWaypoints = This method sets a list of waypoints
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::setWaypoints(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const bool &_startFromCurrentPosition, const std::vector<Routing::WayPoint> &_waypointsList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setWaypoints(_sessionHandle, _routeHandle, _startFromCurrentPosition, _waypointsList, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::setWaypointsAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const bool &_startFromCurrentPosition, const std::vector<Routing::WayPoint> &_waypointsList, SetWaypointsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setWaypointsAsync(_sessionHandle, _routeHandle, _startFromCurrentPosition, _waypointsList, _callback, _info);
}
/**
 * description: getWaypoints = This method retrieves a list of waypoints
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getWaypoints(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, bool &_startFromCurrentPosition, std::vector<Routing::WayPoint> &_waypointsList, const CommonAPI::CallInfo *_info) {
    delegate_->getWaypoints(_routeHandle, _internalCallStatus, _startFromCurrentPosition, _waypointsList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getWaypointsAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetWaypointsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getWaypointsAsync(_routeHandle, _callback, _info);
}
/**
 * description: calculateRoute = This method starts a route calculation
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::calculateRoute(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->calculateRoute(_sessionHandle, _routeHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::calculateRouteAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CalculateRouteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->calculateRouteAsync(_sessionHandle, _routeHandle, _callback, _info);
}
/**
 * description: cancelRouteCalculation = This method cancels a route calculation
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::cancelRouteCalculation(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->cancelRouteCalculation(_sessionHandle, _routeHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::cancelRouteCalculationAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CancelRouteCalculationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->cancelRouteCalculationAsync(_sessionHandle, _routeHandle, _callback, _info);
}
/**
 * description: calculateRoutes = This method allows a client to calculate alternative routes
 *   that differs from a list of already calculated routes
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::calculateRoutes(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_calculatedRoutesList, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_alternativeRoutesList, const CommonAPI::CallInfo *_info) {
    delegate_->calculateRoutes(_sessionHandle, _calculatedRoutesList, _internalCallStatus, _alternativeRoutesList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::calculateRoutesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_calculatedRoutesList, CalculateRoutesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->calculateRoutesAsync(_sessionHandle, _calculatedRoutesList, _callback, _info);
}
/**
 * description: getRouteSegments = This method retrieves a list of segments for a given route
 *   starting from the one closest to the current position to the one closest to
 *   the destination
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getRouteSegments(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const int16_t &_detailLevel, const std::vector<Routing::RouteSegmentType> &_valuesToReturn, const uint32_t &_numberOfSegments, const uint32_t &_offset, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_totalNumberOfSegments, std::vector<Routing::RouteSegment> &_routeSegments, const CommonAPI::CallInfo *_info) {
    delegate_->getRouteSegments(_routeHandle, _detailLevel, _valuesToReturn, _numberOfSegments, _offset, _internalCallStatus, _totalNumberOfSegments, _routeSegments, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getRouteSegmentsAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const int16_t &_detailLevel, const std::vector<Routing::RouteSegmentType> &_valuesToReturn, const uint32_t &_numberOfSegments, const uint32_t &_offset, GetRouteSegmentsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getRouteSegmentsAsync(_routeHandle, _detailLevel, _valuesToReturn, _numberOfSegments, _offset, _callback, _info);
}
/**
 * description: getRouteOverview = This method retrieves general information about a given route
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getRouteOverview(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::RouteOverviewType> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, Routing::RouteOverview &_routeOverview, const CommonAPI::CallInfo *_info) {
    delegate_->getRouteOverview(_routeHandle, _valuesToReturn, _internalCallStatus, _routeOverview, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getRouteOverviewAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::RouteOverviewType> &_valuesToReturn, GetRouteOverviewAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getRouteOverviewAsync(_routeHandle, _valuesToReturn, _callback, _info);
}
/**
 * description: getRouteBoundingBox = This method retrieves the bounding box containing a
 *   calculated route
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getRouteBoundingBox(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::navigation::NavigationTypes::Rectangle &_boundingBox, const CommonAPI::CallInfo *_info) {
    delegate_->getRouteBoundingBox(_routeHandle, _internalCallStatus, _boundingBox, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getRouteBoundingBoxAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetRouteBoundingBoxAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getRouteBoundingBoxAsync(_routeHandle, _callback, _info);
}
/**
 * description: getAllRoutes = This method retrieves the handles of all created routes
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getAllRoutes(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_routesList, const CommonAPI::CallInfo *_info) {
    delegate_->getAllRoutes(_internalCallStatus, _routesList, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getAllRoutesAsync(GetAllRoutesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getAllRoutesAsync(_callback, _info);
}
/**
 * description: setBlockedRouteStretches = This method sets blocked streches on a given route
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::setBlockedRouteStretches(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::BlockedRouteElement> &_blockParameters, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setBlockedRouteStretches(_sessionHandle, _routeHandle, _blockParameters, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::setBlockedRouteStretchesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::BlockedRouteElement> &_blockParameters, SetBlockedRouteStretchesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setBlockedRouteStretchesAsync(_sessionHandle, _routeHandle, _blockParameters, _callback, _info);
}
/**
 * description: getBlockedRouteStretches = This method retrieves all blocked streches on a
 *   given route
 */
template <typename ... _AttributeExtensions>
void RoutingProxy<_AttributeExtensions...>::getBlockedRouteStretches(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::BlockedRouteElement> &_blockParameters, const CommonAPI::CallInfo *_info) {
    delegate_->getBlockedRouteStretches(_routeHandle, _internalCallStatus, _blockParameters, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> RoutingProxy<_AttributeExtensions...>::getBlockedRouteStretchesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetBlockedRouteStretchesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getBlockedRouteStretchesAsync(_routeHandle, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &RoutingProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool RoutingProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool RoutingProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& RoutingProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& RoutingProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace navigationcore
} // namespace navigation
} // namespace genivi
} // namespace org
} // namespace v4



// Compatibility
namespace v4_0 = v4;

#endif // V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_Routing_PROXY_HPP_
