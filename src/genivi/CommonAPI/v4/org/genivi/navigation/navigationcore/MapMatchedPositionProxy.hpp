/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201608040617.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: MapMatchedPosition = This interface offers functions to retrieve the map
 *   matched position and to simulate positioning
 */
#ifndef V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_Map_Matched_Position_PROXY_HPP_
#define V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_Map_Matched_Position_PROXY_HPP_

#include <v4/org/genivi/navigation/navigationcore/MapMatchedPositionProxyBase.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif


#undef COMMONAPI_INTERNAL_COMPILATION

namespace v4 {
namespace org {
namespace genivi {
namespace navigation {
namespace navigationcore {

template <typename ... _AttributeExtensions>
class MapMatchedPositionProxy
    : virtual public MapMatchedPosition, 
      virtual public MapMatchedPositionProxyBase,
      virtual public _AttributeExtensions... {
public:
    MapMatchedPositionProxy(std::shared_ptr<CommonAPI::Proxy> delegate);
    ~MapMatchedPositionProxy();

    typedef MapMatchedPosition InterfaceType;



    /**
     * description: simulationStatusChanged = This signal is emitted when the Simulation Status has
     *   changed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast simulationStatusChanged.
     */
    virtual SimulationStatusChangedEvent& getSimulationStatusChangedEvent() {
        return delegate_->getSimulationStatusChangedEvent();
    }
    /**
     * description: simulationSpeedChanged = This signal is emitted when the simulation speed
     *   factor has changed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast simulationSpeedChanged.
     */
    virtual SimulationSpeedChangedEvent& getSimulationSpeedChangedEvent() {
        return delegate_->getSimulationSpeedChangedEvent();
    }
    /**
     * description: positionUpdate = This signal is called to notify a client application of a
     *   position change. The update frequency is implementation specific. The maximal
     *   allowed frequency is 10Hz
     */
    /**
     * Returns the wrapper class that provides access to the broadcast positionUpdate.
     */
    virtual PositionUpdateEvent& getPositionUpdateEvent() {
        return delegate_->getPositionUpdateEvent();
    }
    /**
     * description: addressUpdate = This signal is called to notify a client application that the
     *   current address changed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast addressUpdate.
     */
    virtual AddressUpdateEvent& getAddressUpdateEvent() {
        return delegate_->getAddressUpdateEvent();
    }
    /**
     * description: positionOnSegmentUpdate = This signal is called to notify the client that the
     *   vehicle position on the route segment changed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast positionOnSegmentUpdate.
     */
    virtual PositionOnSegmentUpdateEvent& getPositionOnSegmentUpdateEvent() {
        return delegate_->getPositionOnSegmentUpdateEvent();
    }
    /**
     * description: statusUpdate = This signal is emitted to notifiy a client application that the
     *   current status changed
     */
    /**
     * Returns the wrapper class that provides access to the broadcast statusUpdate.
     */
    virtual StatusUpdateEvent& getStatusUpdateEvent() {
        return delegate_->getStatusUpdateEvent();
    }
    /**
     * description: offroadPositionChanged = This signal is emitted when the heading and the
     *   distance to the closest point on the road network changes
     */
    /**
     * Returns the wrapper class that provides access to the broadcast offRoadPositionChanged.
     */
    virtual OffRoadPositionChangedEvent& getOffRoadPositionChangedEvent() {
        return delegate_->getOffRoadPositionChangedEvent();
    }

    /**
     * description: getVersion = This method returns the API version implemented by the server
     *   application
     * Calls getVersion with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getVersion(CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::CommonTypes::Version &_version, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getVersion with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getVersionAsync(GetVersionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setSimulationMode = This method activates or deactivates the simulation mode
     * Calls setSimulationMode with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSimulationMode(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const bool &_activate, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSimulationMode with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSimulationModeAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const bool &_activate, SetSimulationModeAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getSimulationStatus = This method retrieves the simulation status
     * Calls getSimulationStatus with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSimulationStatus(CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::SimulationStatus &_simulationStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSimulationStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSimulationStatusAsync(GetSimulationStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: AddSimulationStatusListener = Add this node as a listener to Simulation Status
     *   changes.
     * Calls addSimulationStatusListener with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void addSimulationStatusListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls addSimulationStatusListener with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> addSimulationStatusListenerAsync(AddSimulationStatusListenerAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: RemoveSimulationStatusListener = Remove this node as a listener to Simulation
     *   Status changes.
     * Calls removeSimulationStatusListener with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void removeSimulationStatusListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls removeSimulationStatusListener with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> removeSimulationStatusListenerAsync(RemoveSimulationStatusListenerAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setSimulationSpeed = This method sets the speed factor for the simulation mode
     * Calls setSimulationSpeed with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setSimulationSpeed(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const uint8_t &_speedFactor, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setSimulationSpeed with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setSimulationSpeedAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const uint8_t &_speedFactor, SetSimulationSpeedAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getSimulationSpeed = returns the speed factor for the simulation mode
     * Calls getSimulationSpeed with synchronous semantics.
     * 
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getSimulationSpeed(CommonAPI::CallStatus &_internalCallStatus, uint8_t &_speedFactor, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getSimulationSpeed with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getSimulationSpeedAsync(GetSimulationSpeedAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: AddSimulationSpeedListener = Add this node as a listener to simulation speed
     *   factor changes.
     * Calls addSimulationSpeedListener with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void addSimulationSpeedListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls addSimulationSpeedListener with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> addSimulationSpeedListenerAsync(AddSimulationSpeedListenerAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: RemoveSimulationSpeedListener = Remove this node as a listener to simulation
     *   speed factor changes.
     * Calls removeSimulationSpeedListener with synchronous semantics.
     * 
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void removeSimulationSpeedListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls removeSimulationSpeedListener with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> removeSimulationSpeedListenerAsync(RemoveSimulationSpeedListenerAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: startSimulation = This method starts, or resumes, a Follow Active Route
     *   simulation
     * Calls startSimulation with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void startSimulation(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls startSimulation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> startSimulationAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, StartSimulationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: pauseSimulation = This method freezes the current location
     * Calls pauseSimulation with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void pauseSimulation(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls pauseSimulation with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> pauseSimulationAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, PauseSimulationAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getPosition = This method returns the current position
     * Calls getPosition with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getPosition(const std::vector<MapMatchedPosition::PositionItemKey> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::PositionItemDict &_position, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getPosition with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getPositionAsync(const std::vector<MapMatchedPosition::PositionItemKey> &_valuesToReturn, GetPositionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: setPosition = This method sets the position to a specific location
     * Calls setPosition with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void setPosition(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const MapMatchedPosition::PositionItemDict &_position, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls setPosition with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> setPositionAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const MapMatchedPosition::PositionItemDict &_position, SetPositionAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getAddress = This method returns the current address
     * Calls getCurrentAddress with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getCurrentAddress(const std::vector<MapMatchedPosition::AddressItemKey> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::AddressItemDict &_address, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getCurrentAddress with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getCurrentAddressAsync(const std::vector<MapMatchedPosition::AddressItemKey> &_valuesToReturn, GetCurrentAddressAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: positionOnSegment = This method returns the vehicle position on a route segment
     * Calls getPositionOnSegment with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getPositionOnSegment(const std::vector<MapMatchedPosition::PositionOnSegmentKey> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::PositionOnSegmentDict &_positionOnSegment, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getPositionOnSegment with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getPositionOnSegmentAsync(const std::vector<MapMatchedPosition::PositionOnSegmentKey> &_valuesToReturn, GetPositionOnSegmentAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * description: getStatus = This method returns the current status
     * Calls getStatus with synchronous semantics.
     * 
    * All const parameters are input parameters to this method.
    * All non-const parameters will be filled with the returned values.
     * The CallStatus will be filled when the method returns and indicate either
     * "SUCCESS" or which type of error has occurred. In case of an error, ONLY the CallStatus
     * will be set.
     */
    virtual void getStatus(const std::vector<MapMatchedPosition::PositionStatus> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::PositionStatusDict &_status, const CommonAPI::CallInfo *_info = nullptr);
    /**
     * Calls getStatus with asynchronous semantics.
     * 
     * The provided callback will be called when the reply to this call arrives or
     * an error occurs during the call. The CallStatus will indicate either "SUCCESS"
     * or which type of error has occurred. In case of any error, ONLY the CallStatus
     * will have a defined value.
     * The std::future returned by this method will be fulfilled at arrival of the reply.
     * It will provide the same value for CallStatus as will be handed to the callback.
     */
    virtual std::future<CommonAPI::CallStatus> getStatusAsync(const std::vector<MapMatchedPosition::PositionStatus> &_valuesToReturn, GetStatusAsyncCallback _callback = nullptr, const CommonAPI::CallInfo *_info = nullptr);


    /**
     * Returns the CommonAPI address of the remote partner this proxy communicates with.
     */
    virtual const CommonAPI::Address &getAddress() const;

    /**
     * Returns true if the remote partner for this proxy is currently known to be available.
     */
    virtual bool isAvailable() const;

    /**
     * Returns true if the remote partner for this proxy is available.
     */
    virtual bool isAvailableBlocking() const;

    /**
     * Returns the wrapper class that is used to (de-)register for notifications about
     * the availability of the remote partner of this proxy.
     */
    virtual CommonAPI::ProxyStatusEvent& getProxyStatusEvent();

    /**
     * Returns the wrapper class that is used to access version information of the remote
     * partner of this proxy.
     */
    virtual CommonAPI::InterfaceVersionAttribute& getInterfaceVersionAttribute();

 private:
    std::shared_ptr<MapMatchedPositionProxyBase> delegate_;
};

typedef MapMatchedPositionProxy<> MapMatchedPositionProxyDefault;


//
// MapMatchedPositionProxy Implementation
//
template <typename ... _AttributeExtensions>
MapMatchedPositionProxy<_AttributeExtensions...>::MapMatchedPositionProxy(std::shared_ptr<CommonAPI::Proxy> delegate):
        _AttributeExtensions(*(std::dynamic_pointer_cast<MapMatchedPositionProxyBase>(delegate)))...,
        delegate_(std::dynamic_pointer_cast<MapMatchedPositionProxyBase>(delegate)) {
}

template <typename ... _AttributeExtensions>
MapMatchedPositionProxy<_AttributeExtensions...>::~MapMatchedPositionProxy() {
}

/**
 * description: getVersion = This method returns the API version implemented by the server
 *   application
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::getVersion(CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::CommonTypes::Version &_version, const CommonAPI::CallInfo *_info) {
    delegate_->getVersion(_internalCallStatus, _version, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::getVersionAsync(GetVersionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getVersionAsync(_callback, _info);
}
/**
 * description: setSimulationMode = This method activates or deactivates the simulation mode
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::setSimulationMode(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const bool &_activate, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setSimulationMode(_sessionHandle, _activate, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::setSimulationModeAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const bool &_activate, SetSimulationModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setSimulationModeAsync(_sessionHandle, _activate, _callback, _info);
}
/**
 * description: getSimulationStatus = This method retrieves the simulation status
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::getSimulationStatus(CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::SimulationStatus &_simulationStatus, const CommonAPI::CallInfo *_info) {
    delegate_->getSimulationStatus(_internalCallStatus, _simulationStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::getSimulationStatusAsync(GetSimulationStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSimulationStatusAsync(_callback, _info);
}
/**
 * description: AddSimulationStatusListener = Add this node as a listener to Simulation Status
 *   changes.
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::addSimulationStatusListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->addSimulationStatusListener(_internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::addSimulationStatusListenerAsync(AddSimulationStatusListenerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->addSimulationStatusListenerAsync(_callback, _info);
}
/**
 * description: RemoveSimulationStatusListener = Remove this node as a listener to Simulation
 *   Status changes.
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::removeSimulationStatusListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->removeSimulationStatusListener(_internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::removeSimulationStatusListenerAsync(RemoveSimulationStatusListenerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->removeSimulationStatusListenerAsync(_callback, _info);
}
/**
 * description: setSimulationSpeed = This method sets the speed factor for the simulation mode
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::setSimulationSpeed(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const uint8_t &_speedFactor, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setSimulationSpeed(_sessionHandle, _speedFactor, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::setSimulationSpeedAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const uint8_t &_speedFactor, SetSimulationSpeedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setSimulationSpeedAsync(_sessionHandle, _speedFactor, _callback, _info);
}
/**
 * description: getSimulationSpeed = returns the speed factor for the simulation mode
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::getSimulationSpeed(CommonAPI::CallStatus &_internalCallStatus, uint8_t &_speedFactor, const CommonAPI::CallInfo *_info) {
    delegate_->getSimulationSpeed(_internalCallStatus, _speedFactor, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::getSimulationSpeedAsync(GetSimulationSpeedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getSimulationSpeedAsync(_callback, _info);
}
/**
 * description: AddSimulationSpeedListener = Add this node as a listener to simulation speed
 *   factor changes.
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::addSimulationSpeedListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->addSimulationSpeedListener(_internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::addSimulationSpeedListenerAsync(AddSimulationSpeedListenerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->addSimulationSpeedListenerAsync(_callback, _info);
}
/**
 * description: RemoveSimulationSpeedListener = Remove this node as a listener to simulation
 *   speed factor changes.
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::removeSimulationSpeedListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->removeSimulationSpeedListener(_internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::removeSimulationSpeedListenerAsync(RemoveSimulationSpeedListenerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->removeSimulationSpeedListenerAsync(_callback, _info);
}
/**
 * description: startSimulation = This method starts, or resumes, a Follow Active Route
 *   simulation
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::startSimulation(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->startSimulation(_sessionHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::startSimulationAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, StartSimulationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->startSimulationAsync(_sessionHandle, _callback, _info);
}
/**
 * description: pauseSimulation = This method freezes the current location
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::pauseSimulation(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->pauseSimulation(_sessionHandle, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::pauseSimulationAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, PauseSimulationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->pauseSimulationAsync(_sessionHandle, _callback, _info);
}
/**
 * description: getPosition = This method returns the current position
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::getPosition(const std::vector<MapMatchedPosition::PositionItemKey> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::PositionItemDict &_position, const CommonAPI::CallInfo *_info) {
    delegate_->getPosition(_valuesToReturn, _internalCallStatus, _position, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::getPositionAsync(const std::vector<MapMatchedPosition::PositionItemKey> &_valuesToReturn, GetPositionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getPositionAsync(_valuesToReturn, _callback, _info);
}
/**
 * description: setPosition = This method sets the position to a specific location
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::setPosition(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const MapMatchedPosition::PositionItemDict &_position, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
    delegate_->setPosition(_sessionHandle, _position, _internalCallStatus, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::setPositionAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const MapMatchedPosition::PositionItemDict &_position, SetPositionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->setPositionAsync(_sessionHandle, _position, _callback, _info);
}
/**
 * description: getAddress = This method returns the current address
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::getCurrentAddress(const std::vector<MapMatchedPosition::AddressItemKey> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::AddressItemDict &_address, const CommonAPI::CallInfo *_info) {
    delegate_->getCurrentAddress(_valuesToReturn, _internalCallStatus, _address, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::getCurrentAddressAsync(const std::vector<MapMatchedPosition::AddressItemKey> &_valuesToReturn, GetCurrentAddressAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getCurrentAddressAsync(_valuesToReturn, _callback, _info);
}
/**
 * description: positionOnSegment = This method returns the vehicle position on a route segment
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::getPositionOnSegment(const std::vector<MapMatchedPosition::PositionOnSegmentKey> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::PositionOnSegmentDict &_positionOnSegment, const CommonAPI::CallInfo *_info) {
    delegate_->getPositionOnSegment(_valuesToReturn, _internalCallStatus, _positionOnSegment, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::getPositionOnSegmentAsync(const std::vector<MapMatchedPosition::PositionOnSegmentKey> &_valuesToReturn, GetPositionOnSegmentAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getPositionOnSegmentAsync(_valuesToReturn, _callback, _info);
}
/**
 * description: getStatus = This method returns the current status
 */
template <typename ... _AttributeExtensions>
void MapMatchedPositionProxy<_AttributeExtensions...>::getStatus(const std::vector<MapMatchedPosition::PositionStatus> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::PositionStatusDict &_status, const CommonAPI::CallInfo *_info) {
    delegate_->getStatus(_valuesToReturn, _internalCallStatus, _status, _info);
}

template <typename ... _AttributeExtensions>
std::future<CommonAPI::CallStatus> MapMatchedPositionProxy<_AttributeExtensions...>::getStatusAsync(const std::vector<MapMatchedPosition::PositionStatus> &_valuesToReturn, GetStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
    return delegate_->getStatusAsync(_valuesToReturn, _callback, _info);
}

template <typename ... _AttributeExtensions>
const CommonAPI::Address &MapMatchedPositionProxy<_AttributeExtensions...>::getAddress() const {
    return delegate_->getAddress();
}

template <typename ... _AttributeExtensions>
bool MapMatchedPositionProxy<_AttributeExtensions...>::isAvailable() const {
    return delegate_->isAvailable();
}

template <typename ... _AttributeExtensions>
bool MapMatchedPositionProxy<_AttributeExtensions...>::isAvailableBlocking() const {
    return delegate_->isAvailableBlocking();
}

template <typename ... _AttributeExtensions>
CommonAPI::ProxyStatusEvent& MapMatchedPositionProxy<_AttributeExtensions...>::getProxyStatusEvent() {
    return delegate_->getProxyStatusEvent();
}

template <typename ... _AttributeExtensions>
CommonAPI::InterfaceVersionAttribute& MapMatchedPositionProxy<_AttributeExtensions...>::getInterfaceVersionAttribute() {
    return delegate_->getInterfaceVersionAttribute();
}


} // namespace navigationcore
} // namespace navigation
} // namespace genivi
} // namespace org
} // namespace v4



// Compatibility
namespace v4_0 = v4;

#endif // V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_Map_Matched_Position_PROXY_HPP_
