/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201608040617.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
#include <v4/org/genivi/navigation/navigationcore/GuidanceStubDefault.hpp>
#include <assert.h>

namespace v4 {
namespace org {
namespace genivi {
namespace navigation {
namespace navigationcore {

GuidanceStubDefault::GuidanceStubDefault():
        remoteEventHandler_(this),
        interfaceVersion_(Guidance::getInterfaceVersion()) {
}

const CommonAPI::Version& GuidanceStubDefault::getInterfaceVersion(std::shared_ptr<CommonAPI::ClientId> _client) {
    (void)_client;
    return interfaceVersion_;
}

GuidanceStubRemoteEvent* GuidanceStubDefault::initStubAdapter(const std::shared_ptr<GuidanceStubAdapter> &_adapter) {
    CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_ = _adapter;
    return &remoteEventHandler_;
}


/**
 * description: getVersion = This method returns the API version implemented by the server
 *   application
 */
void GuidanceStubDefault::getVersion(const std::shared_ptr<CommonAPI::ClientId> _client, getVersionReply_t _reply) {
    (void)_client;
    ::v4::org::genivi::CommonTypes::Version version = {};
    _reply(version);
}

/**
 * description: startGuidance = This method starts the guidance for a given route
 */
void GuidanceStubDefault::startGuidance(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, ::v4::org::genivi::navigation::NavigationTypes::Handle _routeHandle, startGuidanceReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeHandle;
    _reply();
}

/**
 * description: stopGuidance = This method stops the guidance
 */
void GuidanceStubDefault::stopGuidance(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, stopGuidanceReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    _reply();
}

/**
 * description: setVoiceGuidance = This method switch on/off the voice guidance
 */
void GuidanceStubDefault::setVoiceGuidance(const std::shared_ptr<CommonAPI::ClientId> _client, bool _activate, std::string _voice, setVoiceGuidanceReply_t _reply) {
    (void)_client;
    (void) _activate;
    (void) _voice;
    _reply();
}

/**
 * description: getGuidanceDetails = This method retrieves guidance information
 */
void GuidanceStubDefault::getGuidanceDetails(const std::shared_ptr<CommonAPI::ClientId> _client, getGuidanceDetailsReply_t _reply) {
    (void)_client;
    bool voiceGuidance = false;
    bool vehicleOnTheRoad = false;
    bool isDestinationReached = false;
    Guidance::ManeuverPhase maneuver = Guidance::ManeuverPhase::CRUISE;
    if (!maneuver.validate()) {
        return;
    }
    _reply(voiceGuidance, vehicleOnTheRoad, isDestinationReached, maneuver);
}

/**
 * description: playVoiceManeuver = This method plays or repeats the last voice guidance
 */
void GuidanceStubDefault::playVoiceManeuver(const std::shared_ptr<CommonAPI::ClientId> _client, playVoiceManeuverReply_t _reply) {
    (void)_client;
    _reply();
}

/**
 * description: getWaypointInformation = This method retrieves the information on the remaining
 *   way points of the route. A point can be the final destination as well as a
 *   stage defined by the user. The returned waypoints are ordered by their
 *   'number'.
 */
void GuidanceStubDefault::getWaypointInformation(const std::shared_ptr<CommonAPI::ClientId> _client, uint16_t _requestedNumberOfWaypoints, getWaypointInformationReply_t _reply) {
    (void)_client;
    (void) _requestedNumberOfWaypoints;
    uint16_t numberOfWaypoints = 0u;
    std::vector<Guidance::WaypointStruct> waypointsList = {};
    _reply(numberOfWaypoints, waypointsList);
}

/**
 * description: This method retrieves the information on the final destination
 */
void GuidanceStubDefault::getDestinationInformation(const std::shared_ptr<CommonAPI::ClientId> _client, getDestinationInformationReply_t _reply) {
    (void)_client;
    uint32_t offset = 0ul;
    uint32_t travelTime = 0ul;
    int32_t direction = 0;
    Guidance::Side side = Guidance::Side::LEFT;
    int16_t timeZone = 0;
    int16_t daylightSavingTime = 0;
    if (!side.validate()) {
        return;
    }
    _reply(offset, travelTime, direction, side, timeZone, daylightSavingTime);
}

/**
 * description: getManeuversList = This method retrieves the list of next maneuvers
 */
void GuidanceStubDefault::getManeuversList(const std::shared_ptr<CommonAPI::ClientId> _client, uint16_t _requestedNumberOfManeuvers, uint32_t _maneuverOffset, getManeuversListReply_t _reply) {
    (void)_client;
    (void) _requestedNumberOfManeuvers;
    (void) _maneuverOffset;
    uint16_t numberOfManeuvers = 0u;
    std::vector<Guidance::Maneuver> maneuversList = {};
    _reply(numberOfManeuvers, maneuversList);
}

/**
 * description: setRouteCalculationMode = This method configures the way the navigation
 *   application wants the navigation core to behave of reroute trigger
 */
void GuidanceStubDefault::setRouteCalculationMode(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, Guidance::CalculationMode _routeCalculationMode, setRouteCalculationModeReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    (void) _routeCalculationMode;
    _reply();
}

/**
 * description: skipNextManeuver = This method allows to jump behind the current maneuver
 */
void GuidanceStubDefault::skipNextManeuver(const std::shared_ptr<CommonAPI::ClientId> _client, ::v4::org::genivi::navigation::NavigationTypes::Handle _sessionHandle, skipNextManeuverReply_t _reply) {
    (void)_client;
    (void) _sessionHandle;
    _reply();
}

/**
 * description: getGuidanceStatus = This method retrieves the guidance status
 */
void GuidanceStubDefault::getGuidanceStatus(const std::shared_ptr<CommonAPI::ClientId> _client, getGuidanceStatusReply_t _reply) {
    (void)_client;
    Guidance::GuidanceStatus guidanceStatus = Guidance::GuidanceStatus::ACTIVE;
    ::v4::org::genivi::navigation::NavigationTypes::Handle routeHandle = 0ul;
    if (!guidanceStatus.validate()) {
        return;
    }
    _reply(guidanceStatus, routeHandle);
}

/**
 * description: setVoiceGuidanceSettings = This method sets the voice guidance settings
 */
void GuidanceStubDefault::setVoiceGuidanceSettings(const std::shared_ptr<CommonAPI::ClientId> _client, Guidance::PromptMode _promptMode, setVoiceGuidanceSettingsReply_t _reply) {
    (void)_client;
    (void) _promptMode;
    _reply();
}

/**
 * description: getVoiceGuidanceSettings = This method returns the used voice guidance settings
 */
void GuidanceStubDefault::getVoiceGuidanceSettings(const std::shared_ptr<CommonAPI::ClientId> _client, getVoiceGuidanceSettingsReply_t _reply) {
    (void)_client;
    Guidance::PromptMode promptMode = Guidance::PromptMode::DISABLED_PROMPT;
    if (!promptMode.validate()) {
        return;
    }
    _reply(promptMode);
}


/**
 * description: vehicleLeftTheRoadNetwork = This signal is emitted when the vehicle exits from
 *   the road network
 */
void GuidanceStubDefault::fireVehicleLeftTheRoadNetworkEvent() {
    assert((CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireVehicleLeftTheRoadNetworkEvent();
}
/**
 * description: guidanceStatusChanged = This signal is emitted when the guidance status changes
 */
void GuidanceStubDefault::fireGuidanceStatusChangedEvent(const ::v4::org::genivi::navigation::navigationcore::Guidance::GuidanceStatus &_guidanceStatus, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle) {
    if (!_guidanceStatus.validate()) {
        return;
    }
    assert((CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireGuidanceStatusChangedEvent(_guidanceStatus, _routeHandle);
}
/**
 * description: waypointReached = This signal is emitted when the destination is reached
 */
void GuidanceStubDefault::fireWaypointReachedEvent(const bool &_isDestination) {
    assert((CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireWaypointReachedEvent(_isDestination);
}
/**
 * description: This signal is emitted each time a maneuver event is going
 */
void GuidanceStubDefault::fireManeuverChangedEvent(const ::v4::org::genivi::navigation::navigationcore::Guidance::ManeuverPhase &_maneuver) {
    if (!_maneuver.validate()) {
        return;
    }
    assert((CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireManeuverChangedEvent(_maneuver);
}
/**
 * description: positionOnRouteChanged = This signal is emitted when the position on the route
 *   changes
 */
void GuidanceStubDefault::firePositionOnRouteChangedEvent(const uint32_t &_offsetOnRoute) {
    assert((CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->firePositionOnRouteChangedEvent(_offsetOnRoute);
}
/**
 * description: vehicleLeftTheRoute = This signal is emitted when the vehicle has left the route
 */
void GuidanceStubDefault::fireVehicleLeftTheRouteEvent() {
    assert((CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireVehicleLeftTheRouteEvent();
}
/**
 * description: positionToRouteChanged = This signal is emitted when the vehicle is
 *   off-the-road network and either the heading or the distance (or both) to the
 *   closest point on the active route changes
 */
void GuidanceStubDefault::firePositionToRouteChangedEvent(const uint32_t &_distance, const int32_t &_direction) {
    assert((CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->firePositionToRouteChangedEvent(_distance, _direction);
}
/**
 * description: activeRouteChanged = This signal is emitted when the active route changes
 */
void GuidanceStubDefault::fireActiveRouteChangedEvent(const ::v4::org::genivi::navigation::navigationcore::Guidance::RouteChangedCause &_changeCause) {
    if (!_changeCause.validate()) {
        return;
    }
    assert((CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock()) !=NULL);
    auto stubAdapter = CommonAPI::Stub<GuidanceStubAdapter, GuidanceStubRemoteEvent>::stubAdapter_.lock();
   	if (stubAdapter)
        stubAdapter->fireActiveRouteChangedEvent(_changeCause);
}


GuidanceStubDefault::RemoteEventHandler::RemoteEventHandler(GuidanceStubDefault *_defaultStub)
    : 
      defaultStub_(_defaultStub) {
}

} // namespace navigationcore
} // namespace navigation
} // namespace genivi
} // namespace org
} // namespace v4
