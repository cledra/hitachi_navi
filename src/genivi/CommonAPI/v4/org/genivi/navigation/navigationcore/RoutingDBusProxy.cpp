/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.v201608040619.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: This interface offers functions that implement the routing functionality of a
 *   navigation system
 */
#include <v4/org/genivi/navigation/navigationcore/RoutingDBusProxy.hpp>

namespace v4 {
namespace org {
namespace genivi {
namespace navigation {
namespace navigationcore {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createRoutingDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<RoutingDBusProxy>(_address, _connection);
}

INITIALIZER(registerRoutingDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		Routing::getInterface(),
		&createRoutingDBusProxy);
}

RoutingDBusProxy::RoutingDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		routeDeleted_(*this, "routeDeleted", "u", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		routeCalculationCancelled_(*this, "routeCalculationCancelled", "u", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		routeCalculationSuccessful_(*this, "routeCalculationSuccessful", "ua{ii}", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<Routing_::UnfullfilledRoutePreferenceDeployment_t*>(nullptr))),
		routeCalculationFailed_(*this, "routeCalculationFailed", "uia{ii}", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<Routing_::UnfullfilledRoutePreferenceDeployment_t*>(nullptr))),
		routeCalculationProgressUpdate_(*this, "routeCalculationProgressUpdate", "uiy", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		alternativeRoutesAvailable_(*this, "alternativeRoutesAvailable", "au", std::make_tuple(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr)))
{
}


RoutingDBusProxy::RouteDeletedEvent& RoutingDBusProxy::getRouteDeletedEvent() {
    return routeDeleted_;
}
RoutingDBusProxy::RouteCalculationCancelledEvent& RoutingDBusProxy::getRouteCalculationCancelledEvent() {
    return routeCalculationCancelled_;
}
RoutingDBusProxy::RouteCalculationSuccessfulEvent& RoutingDBusProxy::getRouteCalculationSuccessfulEvent() {
    return routeCalculationSuccessful_;
}
RoutingDBusProxy::RouteCalculationFailedEvent& RoutingDBusProxy::getRouteCalculationFailedEvent() {
    return routeCalculationFailed_;
}
RoutingDBusProxy::RouteCalculationProgressUpdateEvent& RoutingDBusProxy::getRouteCalculationProgressUpdateEvent() {
    return routeCalculationProgressUpdate_;
}
RoutingDBusProxy::AlternativeRoutesAvailableEvent& RoutingDBusProxy::getAlternativeRoutesAvailableEvent() {
    return alternativeRoutesAvailable_;
}
    
    /**
     * description: This method returns the API version implemented by the server application
     */
    void RoutingDBusProxy::getVersion(CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::CommonTypes::Version &_version, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::CommonTypes::Version, ::v4::org::genivi::CommonTypes_::VersionDeployment_t> deploy_version(static_cast<::v4::org::genivi::CommonTypes_::VersionDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::CommonTypes::Version,::v4::org::genivi::CommonTypes_::VersionDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getVersion",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_version);
_version = deploy_version.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getVersionAsync(GetVersionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::CommonTypes::Version, ::v4::org::genivi::CommonTypes_::VersionDeployment_t> deploy_version(static_cast<::v4::org::genivi::CommonTypes_::VersionDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::CommonTypes::Version,::v4::org::genivi::CommonTypes_::VersionDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getVersion",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v4::org::genivi::CommonTypes::Version, ::v4::org::genivi::CommonTypes_::VersionDeployment_t> _version) {
        	if (_callback)
        		_callback(_internalCallStatus, _version.getValue());
        },
        std::make_tuple(deploy_version));
    }
    /**
     * description: This method creates a route
     */
    void RoutingDBusProxy::createRoute(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "createRoute",
        "u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle,
_internalCallStatus,
deploy_routeHandle);
_routeHandle = deploy_routeHandle.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::createRouteAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CreateRouteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "createRoute",
        "u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> _routeHandle) {
        	if (_callback)
        		_callback(_internalCallStatus, _routeHandle.getValue());
        },
        std::make_tuple(deploy_routeHandle));
    }
    /**
     * description: This method deletes a route and its associated resources
     */
    void RoutingDBusProxy::deleteRoute(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "deleteRoute",
        "uu",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_routeHandle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::deleteRouteAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, DeleteRouteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "deleteRoute",
        "uu",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_routeHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: This method sets the cost model
     */
    void RoutingDBusProxy::setCostModel(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::CostModel &_costModel, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<Routing::CostModel, CommonAPI::EmptyDeployment> deploy_costModel(_costModel, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<Routing::CostModel, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "setCostModel",
        "uui",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_routeHandle, deploy_costModel,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::setCostModelAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::CostModel &_costModel, SetCostModelAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<Routing::CostModel, CommonAPI::EmptyDeployment> deploy_costModel(_costModel, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<Routing::CostModel, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "setCostModel",
        "uui",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_routeHandle, deploy_costModel,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: This method retrieves the selected cost model
     */
    void RoutingDBusProxy::getCostModel(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, Routing::CostModel &_costModel, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<Routing::CostModel, CommonAPI::EmptyDeployment> deploy_costModel(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<Routing::CostModel,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getCostModel",
        "u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_routeHandle,
_internalCallStatus,
deploy_costModel);
_costModel = deploy_costModel.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getCostModelAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetCostModelAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<Routing::CostModel, CommonAPI::EmptyDeployment> deploy_costModel(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<Routing::CostModel,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getCostModel",
        "u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_routeHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<Routing::CostModel, CommonAPI::EmptyDeployment> _costModel) {
        	if (_callback)
        		_callback(_internalCallStatus, _costModel.getValue());
        },
        std::make_tuple(deploy_costModel));
    }
    /**
     * description: This method retrieves a list of supported cost models
     */
    void RoutingDBusProxy::getSupportedCostModels(CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::CostModel> &_costModelsList, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<Routing::CostModel>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_costModelsList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::CostModel>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "getSupportedCostModels",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_costModelsList);
_costModelsList = deploy_costModelsList.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getSupportedCostModelsAsync(GetSupportedCostModelsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<Routing::CostModel>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_costModelsList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::CostModel>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "getSupportedCostModels",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<Routing::CostModel>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> _costModelsList) {
        	if (_callback)
        		_callback(_internalCallStatus, _costModelsList.getValue());
        },
        std::make_tuple(deploy_costModelsList));
    }
    /**
     * description: This method sets a list of route preferences
     */
    void RoutingDBusProxy::setRoutePreferences(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, const std::vector<Routing::RoutePreference> &_roadPreferenceList, const std::vector<Routing::ConditionPreference> &_conditionPreferenceList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_countryCode(_countryCode, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::RoutePreference>, CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>> deploy_roadPreferenceList(_roadPreferenceList, static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::ConditionPreference>, CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>> deploy_conditionPreferenceList(_conditionPreferenceList, static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<std::vector<Routing::RoutePreference>, CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t> >,
            CommonAPI::Deployable<std::vector<Routing::ConditionPreference>, CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "setRoutePreferences",
        "uusa(ii)a(ii)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_routeHandle, deploy_countryCode, deploy_roadPreferenceList, deploy_conditionPreferenceList,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::setRoutePreferencesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, const std::vector<Routing::RoutePreference> &_roadPreferenceList, const std::vector<Routing::ConditionPreference> &_conditionPreferenceList, SetRoutePreferencesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_countryCode(_countryCode, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::RoutePreference>, CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>> deploy_roadPreferenceList(_roadPreferenceList, static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::ConditionPreference>, CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>> deploy_conditionPreferenceList(_conditionPreferenceList, static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >,
            CommonAPI::Deployable<std::vector<Routing::RoutePreference>, CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t> >,
            CommonAPI::Deployable<std::vector<Routing::ConditionPreference>, CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "setRoutePreferences",
        "uusa(ii)a(ii)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_routeHandle, deploy_countryCode, deploy_roadPreferenceList, deploy_conditionPreferenceList,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: This method retrieves a list of selected route preferences
     */
    void RoutingDBusProxy::getRoutePreferences(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::RoutePreference> &_roadPreferenceList, std::vector<Routing::ConditionPreference> &_conditionPreferenceList, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_countryCode(_countryCode, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::RoutePreference>, CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>> deploy_roadPreferenceList(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::ConditionPreference>, CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>> deploy_conditionPreferenceList(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::RoutePreference>,CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>>,
            CommonAPI::Deployable<std::vector<Routing::ConditionPreference>,CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>>
            >
        	>::callMethodWithReply(
        *this,
        "getRoutePreferences",
        "us",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_routeHandle, deploy_countryCode,
_internalCallStatus,
deploy_roadPreferenceList, deploy_conditionPreferenceList);
_roadPreferenceList = deploy_roadPreferenceList.getValue();
_conditionPreferenceList = deploy_conditionPreferenceList.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getRoutePreferencesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::string &_countryCode, GetRoutePreferencesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment> deploy_countryCode(_countryCode, static_cast<CommonAPI::DBus::StringDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::RoutePreference>, CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>> deploy_roadPreferenceList(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::ConditionPreference>, CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>> deploy_conditionPreferenceList(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::string, CommonAPI::DBus::StringDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::RoutePreference>,CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>>,
            CommonAPI::Deployable<std::vector<Routing::ConditionPreference>,CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>>
            >
        	>::callMethodAsync(
        *this,
        "getRoutePreferences",
        "us",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_routeHandle, deploy_countryCode,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<Routing::RoutePreference>, CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>> _roadPreferenceList, CommonAPI::Deployable<std::vector<Routing::ConditionPreference>, CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>> _conditionPreferenceList) {
        	if (_callback)
        		_callback(_internalCallStatus, _roadPreferenceList.getValue(), _conditionPreferenceList.getValue());
        },
        std::make_tuple(deploy_roadPreferenceList, deploy_conditionPreferenceList));
    }
    /**
     * description: This method retrieves a list of supported route preferences
     */
    void RoutingDBusProxy::getSupportedRoutePreferences(CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::RoutePreference> &_routePreferencesList, std::vector<Routing::ConditionPreference> &_conditionPreferenceList, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<Routing::RoutePreference>, CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>> deploy_routePreferencesList(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::ConditionPreference>, CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>> deploy_conditionPreferenceList(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::RoutePreference>,CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>>,
            CommonAPI::Deployable<std::vector<Routing::ConditionPreference>,CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>>
            >
        	>::callMethodWithReply(
        *this,
        "getSupportedRoutePreferences",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_routePreferencesList, deploy_conditionPreferenceList);
_routePreferencesList = deploy_routePreferencesList.getValue();
_conditionPreferenceList = deploy_conditionPreferenceList.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getSupportedRoutePreferencesAsync(GetSupportedRoutePreferencesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<Routing::RoutePreference>, CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>> deploy_routePreferencesList(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::ConditionPreference>, CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>> deploy_conditionPreferenceList(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::RoutePreference>,CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>>,
            CommonAPI::Deployable<std::vector<Routing::ConditionPreference>,CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>>
            >
        	>::callMethodAsync(
        *this,
        "getSupportedRoutePreferences",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<Routing::RoutePreference>, CommonAPI::DBus::ArrayDeployment<Routing_::RoutePreferenceDeployment_t>> _routePreferencesList, CommonAPI::Deployable<std::vector<Routing::ConditionPreference>, CommonAPI::DBus::ArrayDeployment<Routing_::ConditionPreferenceDeployment_t>> _conditionPreferenceList) {
        	if (_callback)
        		_callback(_internalCallStatus, _routePreferencesList.getValue(), _conditionPreferenceList.getValue());
        },
        std::make_tuple(deploy_routePreferencesList, deploy_conditionPreferenceList));
    }
    /**
     * description: This method sets the time schedule for the route to be calculated
     */
    void RoutingDBusProxy::setRouteSchedule(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::RouteSchedule &_routeSchedule, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<Routing::RouteSchedule, Routing_::RouteScheduleDeployment_t> deploy_routeSchedule(_routeSchedule, static_cast<Routing_::RouteScheduleDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<Routing::RouteSchedule, Routing_::RouteScheduleDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "setRouteSchedule",
        "uua{iu}",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_routeHandle, deploy_routeSchedule,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::setRouteScheduleAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const Routing::RouteSchedule &_routeSchedule, SetRouteScheduleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<Routing::RouteSchedule, Routing_::RouteScheduleDeployment_t> deploy_routeSchedule(_routeSchedule, static_cast<Routing_::RouteScheduleDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<Routing::RouteSchedule, Routing_::RouteScheduleDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "setRouteSchedule",
        "uua{iu}",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_routeHandle, deploy_routeSchedule,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: This method gets the time schedule for the route to be calculated
     */
    void RoutingDBusProxy::getRouteSchedule(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::Schedule> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, Routing::RouteSchedule &_routeSchedule, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::Schedule>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<Routing::RouteSchedule, Routing_::RouteScheduleDeployment_t> deploy_routeSchedule(static_cast<Routing_::RouteScheduleDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::Schedule>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<Routing::RouteSchedule,Routing_::RouteScheduleDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getRouteSchedule",
        "uai",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_routeHandle, deploy_valuesToReturn,
_internalCallStatus,
deploy_routeSchedule);
_routeSchedule = deploy_routeSchedule.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getRouteScheduleAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::Schedule> &_valuesToReturn, GetRouteScheduleAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::Schedule>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<Routing::RouteSchedule, Routing_::RouteScheduleDeployment_t> deploy_routeSchedule(static_cast<Routing_::RouteScheduleDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::Schedule>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<Routing::RouteSchedule,Routing_::RouteScheduleDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getRouteSchedule",
        "uai",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_routeHandle, deploy_valuesToReturn,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<Routing::RouteSchedule, Routing_::RouteScheduleDeployment_t> _routeSchedule) {
        	if (_callback)
        		_callback(_internalCallStatus, _routeSchedule.getValue());
        },
        std::make_tuple(deploy_routeSchedule));
    }
    /**
     * description: This method sets a list of means of transportation that must be considered when
     *   calculating a route
     */
    void RoutingDBusProxy::setTransportationMeans(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::TransportationMeans> &_transportationMeansList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::TransportationMeans>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_transportationMeansList(_transportationMeansList, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::TransportationMeans>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "setTransportationMeans",
        "uuai",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_routeHandle, deploy_transportationMeansList,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::setTransportationMeansAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::TransportationMeans> &_transportationMeansList, SetTransportationMeansAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::TransportationMeans>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_transportationMeansList(_transportationMeansList, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::TransportationMeans>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "setTransportationMeans",
        "uuai",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_routeHandle, deploy_transportationMeansList,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: getTransportationMeans = This method retrieves the selected means of
     *   transportation
     */
    void RoutingDBusProxy::getTransportationMeans(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::TransportationMeans> &_transportationMeansList, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::TransportationMeans>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_transportationMeansList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::TransportationMeans>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "getTransportationMeans",
        "u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_routeHandle,
_internalCallStatus,
deploy_transportationMeansList);
_transportationMeansList = deploy_transportationMeansList.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getTransportationMeansAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetTransportationMeansAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::TransportationMeans>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_transportationMeansList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::TransportationMeans>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "getTransportationMeans",
        "u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_routeHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<Routing::TransportationMeans>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> _transportationMeansList) {
        	if (_callback)
        		_callback(_internalCallStatus, _transportationMeansList.getValue());
        },
        std::make_tuple(deploy_transportationMeansList));
    }
    /**
     * description: getSupportedTransportationMeans = This method retrieves a list of supported
     *   means of transportation
     */
    void RoutingDBusProxy::getSupportedTransportationMeans(CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::TransportationMeans> &_transportationMeansList, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<Routing::TransportationMeans>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_transportationMeansList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::TransportationMeans>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "getSupportedTransportationMeans",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_transportationMeansList);
_transportationMeansList = deploy_transportationMeansList.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getSupportedTransportationMeansAsync(GetSupportedTransportationMeansAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<Routing::TransportationMeans>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_transportationMeansList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::TransportationMeans>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "getSupportedTransportationMeans",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<Routing::TransportationMeans>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> _transportationMeansList) {
        	if (_callback)
        		_callback(_internalCallStatus, _transportationMeansList.getValue());
        },
        std::make_tuple(deploy_transportationMeansList));
    }
    /**
     * description: setExcludedAreas = This method sets the areas to be excluded when calculating a
     *   route
     */
    void RoutingDBusProxy::setExcludedAreas(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon> &_excludedAreas, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon>, CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t>> deploy_excludedAreas(_excludedAreas, static_cast<CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon>, CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "setExcludedAreas",
        "uuaa(dd)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_routeHandle, deploy_excludedAreas,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::setExcludedAreasAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon> &_excludedAreas, SetExcludedAreasAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon>, CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t>> deploy_excludedAreas(_excludedAreas, static_cast<CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon>, CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "setExcludedAreas",
        "uuaa(dd)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_routeHandle, deploy_excludedAreas,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: getExcludedAreas = This method retrieves the areas to be excluded when
     *   calculating a route
     */
    void RoutingDBusProxy::getExcludedAreas(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon> &_excludedAreas, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon>, CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t>> deploy_excludedAreas(static_cast<CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon>,CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t>>
            >
        	>::callMethodWithReply(
        *this,
        "getExcludedAreas",
        "u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_routeHandle,
_internalCallStatus,
deploy_excludedAreas);
_excludedAreas = deploy_excludedAreas.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getExcludedAreasAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetExcludedAreasAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon>, CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t>> deploy_excludedAreas(static_cast<CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon>,CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t>>
            >
        	>::callMethodAsync(
        *this,
        "getExcludedAreas",
        "u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_routeHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Polygon>, CommonAPI::DBus::ArrayDeployment<::v4::org::genivi::navigation::NavigationTypes_::PolygonDeployment_t>> _excludedAreas) {
        	if (_callback)
        		_callback(_internalCallStatus, _excludedAreas.getValue());
        },
        std::make_tuple(deploy_excludedAreas));
    }
    /**
     * description: setWaypoints = This method sets a list of waypoints
     */
    void RoutingDBusProxy::setWaypoints(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const bool &_startFromCurrentPosition, const std::vector<Routing::WayPoint> &_waypointsList, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_startFromCurrentPosition(_startFromCurrentPosition, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::WayPoint>, CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t>> deploy_waypointsList(_waypointsList, static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::WayPoint>, CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "setWaypoints",
        "uubaa{i(yv)}",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_routeHandle, deploy_startFromCurrentPosition, deploy_waypointsList,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::setWaypointsAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const bool &_startFromCurrentPosition, const std::vector<Routing::WayPoint> &_waypointsList, SetWaypointsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_startFromCurrentPosition(_startFromCurrentPosition, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::WayPoint>, CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t>> deploy_waypointsList(_waypointsList, static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::WayPoint>, CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "setWaypoints",
        "uubaa{i(yv)}",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_routeHandle, deploy_startFromCurrentPosition, deploy_waypointsList,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: getWaypoints = This method retrieves a list of waypoints
     */
    void RoutingDBusProxy::getWaypoints(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, bool &_startFromCurrentPosition, std::vector<Routing::WayPoint> &_waypointsList, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_startFromCurrentPosition(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::WayPoint>, CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t>> deploy_waypointsList(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<std::vector<Routing::WayPoint>,CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t>>
            >
        	>::callMethodWithReply(
        *this,
        "getWaypoints",
        "u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_routeHandle,
_internalCallStatus,
deploy_startFromCurrentPosition, deploy_waypointsList);
_startFromCurrentPosition = deploy_startFromCurrentPosition.getValue();
_waypointsList = deploy_waypointsList.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getWaypointsAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetWaypointsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_startFromCurrentPosition(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::WayPoint>, CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t>> deploy_waypointsList(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<bool,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<std::vector<Routing::WayPoint>,CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t>>
            >
        	>::callMethodAsync(
        *this,
        "getWaypoints",
        "u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_routeHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> _startFromCurrentPosition, CommonAPI::Deployable<std::vector<Routing::WayPoint>, CommonAPI::DBus::ArrayDeployment<Routing_::WayPointDeployment_t>> _waypointsList) {
        	if (_callback)
        		_callback(_internalCallStatus, _startFromCurrentPosition.getValue(), _waypointsList.getValue());
        },
        std::make_tuple(deploy_startFromCurrentPosition, deploy_waypointsList));
    }
    /**
     * description: calculateRoute = This method starts a route calculation
     */
    void RoutingDBusProxy::calculateRoute(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "calculateRoute",
        "uu",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_routeHandle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::calculateRouteAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CalculateRouteAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "calculateRoute",
        "uu",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_routeHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: cancelRouteCalculation = This method cancels a route calculation
     */
    void RoutingDBusProxy::cancelRouteCalculation(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "cancelRouteCalculation",
        "uu",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_routeHandle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::cancelRouteCalculationAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CancelRouteCalculationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "cancelRouteCalculation",
        "uu",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_routeHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: calculateRoutes = This method allows a client to calculate alternative routes
     *   that differs from a list of already calculated routes
     */
    void RoutingDBusProxy::calculateRoutes(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_calculatedRoutesList, CommonAPI::CallStatus &_internalCallStatus, std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_alternativeRoutesList, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_calculatedRoutesList(_calculatedRoutesList, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_alternativeRoutesList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "calculateRoutes",
        "uau",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_calculatedRoutesList,
_internalCallStatus,
deploy_alternativeRoutesList);
_alternativeRoutesList = deploy_alternativeRoutesList.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::calculateRoutesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_calculatedRoutesList, CalculateRoutesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_calculatedRoutesList(_calculatedRoutesList, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_alternativeRoutesList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "calculateRoutes",
        "uau",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_calculatedRoutesList,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> _alternativeRoutesList) {
        	if (_callback)
        		_callback(_internalCallStatus, _alternativeRoutesList.getValue());
        },
        std::make_tuple(deploy_alternativeRoutesList));
    }
    /**
     * description: getRouteSegments = This method retrieves a list of segments for a given route
     *   starting from the one closest to the current position to the one closest to
     *   the destination
     */
    void RoutingDBusProxy::getRouteSegments(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const int16_t &_detailLevel, const std::vector<Routing::RouteSegmentType> &_valuesToReturn, const uint32_t &_numberOfSegments, const uint32_t &_offset, CommonAPI::CallStatus &_internalCallStatus, uint32_t &_totalNumberOfSegments, std::vector<Routing::RouteSegment> &_routeSegments, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_detailLevel(_detailLevel, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::RouteSegmentType>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_numberOfSegments(_numberOfSegments, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_offset(_offset, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_totalNumberOfSegments(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::RouteSegment>, CommonAPI::DBus::ArrayDeployment<Routing_::RouteSegmentDeployment_t>> deploy_routeSegments(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::RouteSegmentDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::RouteSegmentType>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<std::vector<Routing::RouteSegment>,CommonAPI::DBus::ArrayDeployment<Routing_::RouteSegmentDeployment_t>>
            >
        	>::callMethodWithReply(
        *this,
        "getRouteSegments",
        "unaiuu",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_routeHandle, deploy_detailLevel, deploy_valuesToReturn, deploy_numberOfSegments, deploy_offset,
_internalCallStatus,
deploy_totalNumberOfSegments, deploy_routeSegments);
_totalNumberOfSegments = deploy_totalNumberOfSegments.getValue();
_routeSegments = deploy_routeSegments.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getRouteSegmentsAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const int16_t &_detailLevel, const std::vector<Routing::RouteSegmentType> &_valuesToReturn, const uint32_t &_numberOfSegments, const uint32_t &_offset, GetRouteSegmentsAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment> deploy_detailLevel(_detailLevel, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::RouteSegmentType>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_numberOfSegments(_numberOfSegments, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_offset(_offset, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> deploy_totalNumberOfSegments(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::RouteSegment>, CommonAPI::DBus::ArrayDeployment<Routing_::RouteSegmentDeployment_t>> deploy_routeSegments(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::RouteSegmentDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<int16_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::RouteSegmentType>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint32_t,CommonAPI::EmptyDeployment>,
            CommonAPI::Deployable<std::vector<Routing::RouteSegment>,CommonAPI::DBus::ArrayDeployment<Routing_::RouteSegmentDeployment_t>>
            >
        	>::callMethodAsync(
        *this,
        "getRouteSegments",
        "unaiuu",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_routeHandle, deploy_detailLevel, deploy_valuesToReturn, deploy_numberOfSegments, deploy_offset,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<uint32_t, CommonAPI::EmptyDeployment> _totalNumberOfSegments, CommonAPI::Deployable<std::vector<Routing::RouteSegment>, CommonAPI::DBus::ArrayDeployment<Routing_::RouteSegmentDeployment_t>> _routeSegments) {
        	if (_callback)
        		_callback(_internalCallStatus, _totalNumberOfSegments.getValue(), _routeSegments.getValue());
        },
        std::make_tuple(deploy_totalNumberOfSegments, deploy_routeSegments));
    }
    /**
     * description: getRouteOverview = This method retrieves general information about a given route
     */
    void RoutingDBusProxy::getRouteOverview(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::RouteOverviewType> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, Routing::RouteOverview &_routeOverview, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::RouteOverviewType>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<Routing::RouteOverview, Routing_::RouteOverviewDeployment_t> deploy_routeOverview(static_cast<Routing_::RouteOverviewDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::RouteOverviewType>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<Routing::RouteOverview,Routing_::RouteOverviewDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getRouteOverview",
        "uai",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_routeHandle, deploy_valuesToReturn,
_internalCallStatus,
deploy_routeOverview);
_routeOverview = deploy_routeOverview.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getRouteOverviewAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::RouteOverviewType> &_valuesToReturn, GetRouteOverviewAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::RouteOverviewType>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<Routing::RouteOverview, Routing_::RouteOverviewDeployment_t> deploy_routeOverview(static_cast<Routing_::RouteOverviewDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::RouteOverviewType>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<Routing::RouteOverview,Routing_::RouteOverviewDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getRouteOverview",
        "uai",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_routeHandle, deploy_valuesToReturn,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<Routing::RouteOverview, Routing_::RouteOverviewDeployment_t> _routeOverview) {
        	if (_callback)
        		_callback(_internalCallStatus, _routeOverview.getValue());
        },
        std::make_tuple(deploy_routeOverview));
    }
    /**
     * description: getRouteBoundingBox = This method retrieves the bounding box containing a
     *   calculated route
     */
    void RoutingDBusProxy::getRouteBoundingBox(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::navigation::NavigationTypes::Rectangle &_boundingBox, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Rectangle, ::v4::org::genivi::navigation::NavigationTypes_::RectangleDeployment_t> deploy_boundingBox(static_cast<::v4::org::genivi::navigation::NavigationTypes_::RectangleDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Rectangle,::v4::org::genivi::navigation::NavigationTypes_::RectangleDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getRouteBoundingBox",
        "u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_routeHandle,
_internalCallStatus,
deploy_boundingBox);
_boundingBox = deploy_boundingBox.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getRouteBoundingBoxAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetRouteBoundingBoxAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Rectangle, ::v4::org::genivi::navigation::NavigationTypes_::RectangleDeployment_t> deploy_boundingBox(static_cast<::v4::org::genivi::navigation::NavigationTypes_::RectangleDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Rectangle,::v4::org::genivi::navigation::NavigationTypes_::RectangleDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getRouteBoundingBox",
        "u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_routeHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Rectangle, ::v4::org::genivi::navigation::NavigationTypes_::RectangleDeployment_t> _boundingBox) {
        	if (_callback)
        		_callback(_internalCallStatus, _boundingBox.getValue());
        },
        std::make_tuple(deploy_boundingBox));
    }
    /**
     * description: getAllRoutes = This method retrieves the handles of all created routes
     */
    void RoutingDBusProxy::getAllRoutes(CommonAPI::CallStatus &_internalCallStatus, std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle> &_routesList, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_routesList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodWithReply(
        *this,
        "getAllRoutes",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_routesList);
_routesList = deploy_routesList.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getAllRoutesAsync(GetAllRoutesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_routesList(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>,CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>>
            >
        	>::callMethodAsync(
        *this,
        "getAllRoutes",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<::v4::org::genivi::navigation::NavigationTypes::Handle>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> _routesList) {
        	if (_callback)
        		_callback(_internalCallStatus, _routesList.getValue());
        },
        std::make_tuple(deploy_routesList));
    }
    /**
     * description: setBlockedRouteStretches = This method sets blocked streches on a given route
     */
    void RoutingDBusProxy::setBlockedRouteStretches(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::BlockedRouteElement> &_blockParameters, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::BlockedRouteElement>, CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t>> deploy_blockParameters(_blockParameters, static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::BlockedRouteElement>, CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "setBlockedRouteStretches",
        "uua(uu)",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_routeHandle, deploy_blockParameters,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::setBlockedRouteStretchesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, const std::vector<Routing::BlockedRouteElement> &_blockParameters, SetBlockedRouteStretchesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::BlockedRouteElement>, CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t>> deploy_blockParameters(_blockParameters, static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<std::vector<Routing::BlockedRouteElement>, CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "setBlockedRouteStretches",
        "uua(uu)",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_routeHandle, deploy_blockParameters,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: getBlockedRouteStretches = This method retrieves all blocked streches on a
     *   given route
     */
    void RoutingDBusProxy::getBlockedRouteStretches(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, CommonAPI::CallStatus &_internalCallStatus, std::vector<Routing::BlockedRouteElement> &_blockParameters, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::BlockedRouteElement>, CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t>> deploy_blockParameters(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t>*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::BlockedRouteElement>,CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t>>
            >
        	>::callMethodWithReply(
        *this,
        "getBlockedRouteStretches",
        "u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_routeHandle,
_internalCallStatus,
deploy_blockParameters);
_blockParameters = deploy_blockParameters.getValue();
}
    std::future<CommonAPI::CallStatus> RoutingDBusProxy::getBlockedRouteStretchesAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_routeHandle, GetBlockedRouteStretchesAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_routeHandle(_routeHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<std::vector<Routing::BlockedRouteElement>, CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t>> deploy_blockParameters(static_cast<CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t>*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<Routing::BlockedRouteElement>,CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t>>
            >
        	>::callMethodAsync(
        *this,
        "getBlockedRouteStretches",
        "u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_routeHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<std::vector<Routing::BlockedRouteElement>, CommonAPI::DBus::ArrayDeployment<Routing_::BlockedRouteElementDeployment_t>> _blockParameters) {
        	if (_callback)
        		_callback(_internalCallStatus, _blockParameters.getValue());
        },
        std::make_tuple(deploy_blockParameters));
    }


void RoutingDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 4;
          ownVersionMinor = 0;
      }

      } // namespace navigationcore
      } // namespace navigation
      } // namespace genivi
      } // namespace org
      } // namespace v4
