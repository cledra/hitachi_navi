/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201608040617.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: Guidance = This interface offers functions that implement the route-guidance
 *   functionality of a navigation system
 */
#ifndef V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_GUIDANCE_HPP_
#define V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_GUIDANCE_HPP_


#include <v4/org/genivi/navigation/NavigationTypes.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/ByteBuffer.hpp>
#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>
#include <unordered_map>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v4 {
namespace org {
namespace genivi {
namespace navigation {
namespace navigationcore {

class Guidance {
public:
    virtual ~Guidance() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    
    struct Side : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            LEFT = 128,
            RIGHT = 131,
            NOT_AVAILABLE = 2
        };
        
        Side() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        Side(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        Side &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::LEFT):
                case static_cast<int32_t>(Literal::RIGHT):
                case static_cast<int32_t>(Literal::NOT_AVAILABLE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const Side &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const Side &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const Side &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const Side &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const Side &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const Side &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct LaneType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            LANE_INFO_BITMASK_STRAIGHT = 1,
            LANE_INFO_BITMASK_SLIGHTRIGHT = 2,
            LANE_INFO_BITMASK_RIGHT = 4,
            LANE_INFO_BITMASK_SHARPRIGHT = 8,
            LANE_INFO_BITMASK_RIGHTUTURN = 16,
            LANE_INFO_BITMASK_SLIGHTLEFT = 32,
            LANE_INFO_BITMASK_LEFT = 64,
            LANE_INFO_BITMASK_SHARPLEFT = 128,
            LANE_INFO_BITMASK_LEFTUTURN = 256
        };
        
        LaneType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        LaneType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        LaneType &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::LANE_INFO_BITMASK_STRAIGHT):
                case static_cast<int32_t>(Literal::LANE_INFO_BITMASK_SLIGHTRIGHT):
                case static_cast<int32_t>(Literal::LANE_INFO_BITMASK_RIGHT):
                case static_cast<int32_t>(Literal::LANE_INFO_BITMASK_SHARPRIGHT):
                case static_cast<int32_t>(Literal::LANE_INFO_BITMASK_RIGHTUTURN):
                case static_cast<int32_t>(Literal::LANE_INFO_BITMASK_SLIGHTLEFT):
                case static_cast<int32_t>(Literal::LANE_INFO_BITMASK_LEFT):
                case static_cast<int32_t>(Literal::LANE_INFO_BITMASK_SHARPLEFT):
                case static_cast<int32_t>(Literal::LANE_INFO_BITMASK_LEFTUTURN):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LaneType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LaneType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LaneType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LaneType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LaneType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LaneType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct PromptMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            DISABLED_PROMPT = 65,
            AUTOMATIC_PROMPT = 66,
            MANUAL_PROMPT = 67
        };
        
        PromptMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        PromptMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        PromptMode &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::DISABLED_PROMPT):
                case static_cast<int32_t>(Literal::AUTOMATIC_PROMPT):
                case static_cast<int32_t>(Literal::MANUAL_PROMPT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PromptMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PromptMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PromptMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PromptMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PromptMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PromptMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ManeuverPhase : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            CRUISE = 80,
            MANEUVER_APPEARED = 81,
            PRE_ADVICE = 82,
            ADVICE = 83,
            PASSED = 84
        };
        
        ManeuverPhase() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        ManeuverPhase(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        ManeuverPhase &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::CRUISE):
                case static_cast<int32_t>(Literal::MANEUVER_APPEARED):
                case static_cast<int32_t>(Literal::PRE_ADVICE):
                case static_cast<int32_t>(Literal::ADVICE):
                case static_cast<int32_t>(Literal::PASSED):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ManeuverPhase &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ManeuverPhase &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ManeuverPhase &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ManeuverPhase &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ManeuverPhase &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ManeuverPhase &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct GuidanceStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            ACTIVE = 96,
            INACTIVE = 97
        };
        
        GuidanceStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        GuidanceStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        GuidanceStatus &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::ACTIVE):
                case static_cast<int32_t>(Literal::INACTIVE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const GuidanceStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const GuidanceStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const GuidanceStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const GuidanceStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const GuidanceStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const GuidanceStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ManeuverType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            STRAIGHT_ON = 112,
            CROSSROAD = 113,
            ROUNDABOUT = 114,
            HIGHWAY_ENTER = 115,
            HIGHWAY_EXIT = 116,
            FOLLOW_SPECIFIC_LANE = 117,
            DESTINATION = 118,
            WAYPOINT = 119,
            TURN = 120,
            BIFURCATION = 121
        };
        
        ManeuverType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        ManeuverType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        ManeuverType &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::STRAIGHT_ON):
                case static_cast<int32_t>(Literal::CROSSROAD):
                case static_cast<int32_t>(Literal::ROUNDABOUT):
                case static_cast<int32_t>(Literal::HIGHWAY_ENTER):
                case static_cast<int32_t>(Literal::HIGHWAY_EXIT):
                case static_cast<int32_t>(Literal::FOLLOW_SPECIFIC_LANE):
                case static_cast<int32_t>(Literal::DESTINATION):
                case static_cast<int32_t>(Literal::WAYPOINT):
                case static_cast<int32_t>(Literal::TURN):
                case static_cast<int32_t>(Literal::BIFURCATION):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ManeuverType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ManeuverType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ManeuverType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ManeuverType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ManeuverType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ManeuverType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ManeuverDirection : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            STRAIGHT_ON = 127,
            LEFT = 128,
            SLIGHT_LEFT = 129,
            HARD_LEFT = 130,
            RIGHT = 131,
            SLIGHT_RIGHT = 132,
            HARD_RIGHT = 133,
            UTURN_RIGHT = 134,
            UTURN_LEFT = 135
        };
        
        ManeuverDirection() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        ManeuverDirection(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        ManeuverDirection &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::STRAIGHT_ON):
                case static_cast<int32_t>(Literal::LEFT):
                case static_cast<int32_t>(Literal::SLIGHT_LEFT):
                case static_cast<int32_t>(Literal::HARD_LEFT):
                case static_cast<int32_t>(Literal::RIGHT):
                case static_cast<int32_t>(Literal::SLIGHT_RIGHT):
                case static_cast<int32_t>(Literal::HARD_RIGHT):
                case static_cast<int32_t>(Literal::UTURN_RIGHT):
                case static_cast<int32_t>(Literal::UTURN_LEFT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ManeuverDirection &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ManeuverDirection &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ManeuverDirection &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ManeuverDirection &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ManeuverDirection &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ManeuverDirection &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct CalculationMode : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            ALL_MANUAL = 144,
            ALL_AUTOMATIC = 145,
            TRAFFIC_MANUAL = 146,
            OFF_ROUTE_MANUAL = 147
        };
        
        CalculationMode() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        CalculationMode(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        CalculationMode &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::ALL_MANUAL):
                case static_cast<int32_t>(Literal::ALL_AUTOMATIC):
                case static_cast<int32_t>(Literal::TRAFFIC_MANUAL):
                case static_cast<int32_t>(Literal::OFF_ROUTE_MANUAL):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const CalculationMode &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const CalculationMode &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const CalculationMode &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const CalculationMode &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const CalculationMode &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const CalculationMode &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct RoadProperty : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            UNDEFINED = 256,
            TOLL_ROADS = 257
        };
        
        RoadProperty() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        RoadProperty(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        RoadProperty &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::UNDEFINED):
                case static_cast<int32_t>(Literal::TOLL_ROADS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const RoadProperty &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const RoadProperty &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const RoadProperty &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const RoadProperty &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const RoadProperty &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const RoadProperty &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct RouteChangedCause : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            TRAFFIC = 528,
            OFF_ROUTE = 529,
            MANUAL = 530
        };
        
        RouteChangedCause() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        RouteChangedCause(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        RouteChangedCause &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::TRAFFIC):
                case static_cast<int32_t>(Literal::OFF_ROUTE):
                case static_cast<int32_t>(Literal::MANUAL):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const RouteChangedCause &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const RouteChangedCause &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const RouteChangedCause &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const RouteChangedCause &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const RouteChangedCause &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const RouteChangedCause &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ManeuverDirectionType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            DIRECTION = 576,
            EXIT_NUMBER = 577,
            ROAD_FORM = 578,
            LANE_INFO = 579
        };
        
        ManeuverDirectionType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        ManeuverDirectionType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        ManeuverDirectionType &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::DIRECTION):
                case static_cast<int32_t>(Literal::EXIT_NUMBER):
                case static_cast<int32_t>(Literal::ROAD_FORM):
                case static_cast<int32_t>(Literal::LANE_INFO):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ManeuverDirectionType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ManeuverDirectionType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ManeuverDirectionType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ManeuverDirectionType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ManeuverDirectionType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ManeuverDirectionType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct LaneDivider : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            DIVIDER_UNDEFINED = 592,
            DIVIDER_INTERRUPTEDLONG = 593,
            DIVIDER_INTERRUPTEDSHORT = 594,
            DIVIDER_SOLIDSINGLE = 595,
            DIVIDER_SOLIDDOUBLE = 596,
            DIVIDER_SOLIDINTERRUPTED = 597,
            DIVIDER_INTERRUPTEDSOLID = 598
        };
        
        LaneDivider() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        LaneDivider(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        LaneDivider &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::DIVIDER_UNDEFINED):
                case static_cast<int32_t>(Literal::DIVIDER_INTERRUPTEDLONG):
                case static_cast<int32_t>(Literal::DIVIDER_INTERRUPTEDSHORT):
                case static_cast<int32_t>(Literal::DIVIDER_SOLIDSINGLE):
                case static_cast<int32_t>(Literal::DIVIDER_SOLIDDOUBLE):
                case static_cast<int32_t>(Literal::DIVIDER_SOLIDINTERRUPTED):
                case static_cast<int32_t>(Literal::DIVIDER_INTERRUPTEDSOLID):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const LaneDivider &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const LaneDivider &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const LaneDivider &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const LaneDivider &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const LaneDivider &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const LaneDivider &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    
    struct ManeuverDataAttribute : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            INVALID = 0,
            ALL = 65535,
            LENGTH = 608,
            DIRECTION = 609,
            EXIT_NUMBER = 610,
            ROAD_FORM = 611,
            LANE_INFO = 612,
            LATITUDE = 613,
            LONGITUDE = 614,
            ALTITUDE = 615
        };
        
        ManeuverDataAttribute() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::INVALID)) {}
        ManeuverDataAttribute(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
        ManeuverDataAttribute &operator=(const ::v4::org::genivi::navigation::NavigationTypes::BasicEnum::Literal &_value) {
            value_ = static_cast<int32_t>(_value);
            return (*this);
        }
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::INVALID):
                case static_cast<int32_t>(Literal::ALL):
                case static_cast<int32_t>(Literal::LENGTH):
                case static_cast<int32_t>(Literal::DIRECTION):
                case static_cast<int32_t>(Literal::EXIT_NUMBER):
                case static_cast<int32_t>(Literal::ROAD_FORM):
                case static_cast<int32_t>(Literal::LANE_INFO):
                case static_cast<int32_t>(Literal::LATITUDE):
                case static_cast<int32_t>(Literal::LONGITUDE):
                case static_cast<int32_t>(Literal::ALTITUDE):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ManeuverDataAttribute &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ManeuverDataAttribute &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ManeuverDataAttribute &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ManeuverDataAttribute &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ManeuverDataAttribute &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ManeuverDataAttribute &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    struct LaneInfo : CommonAPI::Struct<uint32_t, CommonAPI::ByteBuffer, LaneType, LaneDivider> {
    	
    	LaneInfo() {
    	}
    	LaneInfo(const uint32_t &_laneIndex, const CommonAPI::ByteBuffer &_laneDirections, const LaneType &_directionToFollow, const LaneDivider &_divider)
    	{
    		std::get<0>(values_) = _laneIndex;
    		std::get<1>(values_) = _laneDirections;
    		std::get<2>(values_) = _directionToFollow;
    		std::get<3>(values_) = _divider;
    	}
    	inline const uint32_t &getLaneIndex() const { return std::get<0>(values_); }
    	inline void setLaneIndex(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	inline const CommonAPI::ByteBuffer &getLaneDirections() const { return std::get<1>(values_); }
    	inline void setLaneDirections(const CommonAPI::ByteBuffer &_value) { std::get<1>(values_) = _value; }
    	inline const LaneType &getDirectionToFollow() const { return std::get<2>(values_); }
    	inline void setDirectionToFollow(const LaneType &_value) { std::get<2>(values_) = _value; }
    	inline const LaneDivider &getDivider() const { return std::get<3>(values_); }
    	inline void setDivider(const LaneDivider &_value) { std::get<3>(values_) = _value; }
    	inline bool operator==(const LaneInfo& _other) const {
                return (getLaneIndex() == _other.getLaneIndex() && getLaneDirections() == _other.getLaneDirections() && getDirectionToFollow() == _other.getDirectionToFollow() && getDivider() == _other.getDivider());
        }
    	inline bool operator!=(const LaneInfo &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    typedef CommonAPI::Variant<ManeuverDirection, std::string, std::vector<LaneInfo>, ::v4::org::genivi::navigation::NavigationTypes::Coordinate3D>  ManeuverDataValue;
    typedef std::unordered_map<::v4::org::genivi::navigation::navigationcore::Guidance::ManeuverDataAttribute, ::v4::org::genivi::navigation::navigationcore::Guidance::ManeuverDataValue, CommonAPI::EnumHasher<::v4::org::genivi::navigation::navigationcore::Guidance::ManeuverDataAttribute>> ManeuverData;
    struct WaypointStruct : CommonAPI::Struct<uint32_t, uint32_t, int32_t, Side, int16_t, int16_t, bool, uint16_t> {
    	
    	WaypointStruct() {
    		std::get<6>(values_) = false;
    	}
    	WaypointStruct(const uint32_t &_waypointOffset, const uint32_t &_travelTime, const int32_t &_direction, const Side &_side, const int16_t &_timeZone, const int16_t &_daylightSavingTime, const bool &_isDestination, const uint16_t &_number)
    	{
    		std::get<0>(values_) = _waypointOffset;
    		std::get<1>(values_) = _travelTime;
    		std::get<2>(values_) = _direction;
    		std::get<3>(values_) = _side;
    		std::get<4>(values_) = _timeZone;
    		std::get<5>(values_) = _daylightSavingTime;
    		std::get<6>(values_) = _isDestination;
    		std::get<7>(values_) = _number;
    	}
    	inline const uint32_t &getWaypointOffset() const { return std::get<0>(values_); }
    	inline void setWaypointOffset(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	inline const uint32_t &getTravelTime() const { return std::get<1>(values_); }
    	inline void setTravelTime(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline const int32_t &getDirection() const { return std::get<2>(values_); }
    	inline void setDirection(const int32_t &_value) { std::get<2>(values_) = _value; }
    	inline const Side &getSide() const { return std::get<3>(values_); }
    	inline void setSide(const Side &_value) { std::get<3>(values_) = _value; }
    	inline const int16_t &getTimeZone() const { return std::get<4>(values_); }
    	inline void setTimeZone(const int16_t &_value) { std::get<4>(values_) = _value; }
    	inline const int16_t &getDaylightSavingTime() const { return std::get<5>(values_); }
    	inline void setDaylightSavingTime(const int16_t &_value) { std::get<5>(values_) = _value; }
    	inline const bool &getIsDestination() const { return std::get<6>(values_); }
    	inline void setIsDestination(const bool _value) { std::get<6>(values_) = _value; }
    	inline const uint16_t &getNumber() const { return std::get<7>(values_); }
    	inline void setNumber(const uint16_t &_value) { std::get<7>(values_) = _value; }
    	inline bool operator==(const WaypointStruct& _other) const {
                return (getWaypointOffset() == _other.getWaypointOffset() && getTravelTime() == _other.getTravelTime() && getDirection() == _other.getDirection() && getSide() == _other.getSide() && getTimeZone() == _other.getTimeZone() && getDaylightSavingTime() == _other.getDaylightSavingTime() && getIsDestination() == _other.getIsDestination() && getNumber() == _other.getNumber());
        }
    	inline bool operator!=(const WaypointStruct &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: struct generated for DBus argument GetManeuversList_maneuversListElem6
     */
    struct ManeuverItem : CommonAPI::Struct<uint32_t, uint32_t, ManeuverDirectionType, ManeuverType, ManeuverData> {
    	
    	ManeuverItem() {
    	}
    	ManeuverItem(const uint32_t &_offsetOfManeuver, const uint32_t &_travelTime, const ManeuverDirectionType &_direction, const ManeuverType &_maneuver, const ManeuverData &_maneuverData)
    	{
    		std::get<0>(values_) = _offsetOfManeuver;
    		std::get<1>(values_) = _travelTime;
    		std::get<2>(values_) = _direction;
    		std::get<3>(values_) = _maneuver;
    		std::get<4>(values_) = _maneuverData;
    	}
    	inline const uint32_t &getOffsetOfManeuver() const { return std::get<0>(values_); }
    	inline void setOffsetOfManeuver(const uint32_t &_value) { std::get<0>(values_) = _value; }
    	inline const uint32_t &getTravelTime() const { return std::get<1>(values_); }
    	inline void setTravelTime(const uint32_t &_value) { std::get<1>(values_) = _value; }
    	inline const ManeuverDirectionType &getDirection() const { return std::get<2>(values_); }
    	inline void setDirection(const ManeuverDirectionType &_value) { std::get<2>(values_) = _value; }
    	inline const ManeuverType &getManeuver() const { return std::get<3>(values_); }
    	inline void setManeuver(const ManeuverType &_value) { std::get<3>(values_) = _value; }
    	inline const ManeuverData &getManeuverData() const { return std::get<4>(values_); }
    	inline void setManeuverData(const ManeuverData &_value) { std::get<4>(values_) = _value; }
    	inline bool operator==(const ManeuverItem& _other) const {
                return (getOffsetOfManeuver() == _other.getOffsetOfManeuver() && getTravelTime() == _other.getTravelTime() && getDirection() == _other.getDirection() && getManeuver() == _other.getManeuver() && getManeuverData() == _other.getManeuverData());
        }
    	inline bool operator!=(const ManeuverItem &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: struct generated for DBus argument GetManeuversList_maneuversList
     */
    struct Maneuver : CommonAPI::Struct<std::string, std::string, RoadProperty, Side, uint32_t, std::vector<ManeuverItem>> {
    	
    	Maneuver() {
    	}
    	Maneuver(const std::string &_roadNumberAfterManeuver, const std::string &_roadNameAfterManeuver, const RoadProperty &_roadPropertyAfterManeuver, const Side &_drivingSide, const uint32_t &_offsetOfNextManeuver, const std::vector<ManeuverItem> &_items)
    	{
    		std::get<0>(values_) = _roadNumberAfterManeuver;
    		std::get<1>(values_) = _roadNameAfterManeuver;
    		std::get<2>(values_) = _roadPropertyAfterManeuver;
    		std::get<3>(values_) = _drivingSide;
    		std::get<4>(values_) = _offsetOfNextManeuver;
    		std::get<5>(values_) = _items;
    	}
    	inline const std::string &getRoadNumberAfterManeuver() const { return std::get<0>(values_); }
    	inline void setRoadNumberAfterManeuver(const std::string &_value) { std::get<0>(values_) = _value; }
    	inline const std::string &getRoadNameAfterManeuver() const { return std::get<1>(values_); }
    	inline void setRoadNameAfterManeuver(const std::string &_value) { std::get<1>(values_) = _value; }
    	inline const RoadProperty &getRoadPropertyAfterManeuver() const { return std::get<2>(values_); }
    	inline void setRoadPropertyAfterManeuver(const RoadProperty &_value) { std::get<2>(values_) = _value; }
    	inline const Side &getDrivingSide() const { return std::get<3>(values_); }
    	inline void setDrivingSide(const Side &_value) { std::get<3>(values_) = _value; }
    	inline const uint32_t &getOffsetOfNextManeuver() const { return std::get<4>(values_); }
    	inline void setOffsetOfNextManeuver(const uint32_t &_value) { std::get<4>(values_) = _value; }
    	inline const std::vector<ManeuverItem> &getItems() const { return std::get<5>(values_); }
    	inline void setItems(const std::vector<ManeuverItem> &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const Maneuver& _other) const {
                return (getRoadNumberAfterManeuver() == _other.getRoadNumberAfterManeuver() && getRoadNameAfterManeuver() == _other.getRoadNameAfterManeuver() && getRoadPropertyAfterManeuver() == _other.getRoadPropertyAfterManeuver() && getDrivingSide() == _other.getDrivingSide() && getOffsetOfNextManeuver() == _other.getOffsetOfNextManeuver() && getItems() == _other.getItems());
        }
    	inline bool operator!=(const Maneuver &_other) const {
    		return !((*this) == _other);
    	}
    
    };
};

const char* Guidance::getInterface() {
    return ("org.genivi.navigation.navigationcore.Guidance");
}

CommonAPI::Version Guidance::getInterfaceVersion() {
    return CommonAPI::Version(4, 0);
}

/**
 * description: struct generated for DBus argument GetManeuversList_maneuversListElem6
 */
/**
 * description: struct generated for DBus argument GetManeuversList_maneuversList
 */

} // namespace navigationcore
} // namespace navigation
} // namespace genivi
} // namespace org
} // namespace v4

namespace CommonAPI {
}


// Compatibility
namespace v4_0 = v4;

#endif // V4_ORG_GENIVI_NAVIGATION_NAVIGATIONCORE_GUIDANCE_HPP_
