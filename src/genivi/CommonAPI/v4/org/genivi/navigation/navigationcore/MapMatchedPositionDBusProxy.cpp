/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.dbus 3.1.5.v201608040619.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: MapMatchedPosition = This interface offers functions to retrieve the map
 *   matched position and to simulate positioning
 */
#include <v4/org/genivi/navigation/navigationcore/MapMatchedPositionDBusProxy.hpp>

namespace v4 {
namespace org {
namespace genivi {
namespace navigation {
namespace navigationcore {

std::shared_ptr<CommonAPI::DBus::DBusProxy> createMapMatchedPositionDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection) {
	return std::make_shared<MapMatchedPositionDBusProxy>(_address, _connection);
}

INITIALIZER(registerMapMatchedPositionDBusProxy) {
     CommonAPI::DBus::Factory::get()->registerProxyCreateMethod(
		MapMatchedPosition::getInterface(),
		&createMapMatchedPositionDBusProxy);
}

MapMatchedPositionDBusProxy::MapMatchedPositionDBusProxy(
	const CommonAPI::DBus::DBusAddress &_address,
	const std::shared_ptr<CommonAPI::DBus::DBusProxyConnection> &_connection)
	:	CommonAPI::DBus::DBusProxy(_address, _connection)
,		simulationStatusChanged_(*this, "simulationStatusChanged", "i", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		simulationSpeedChanged_(*this, "simulationSpeedChanged", "y", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr))),
		positionUpdate_(*this, "positionUpdate", "ai", std::make_tuple(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr))),
		addressUpdate_(*this, "addressUpdate", "ai", std::make_tuple(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr))),
		positionOnSegmentUpdate_(*this, "positionOnSegmentUpdate", "ai", std::make_tuple(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr))),
		statusUpdate_(*this, "statusUpdate", "ai", std::make_tuple(static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr))),
		offRoadPositionChanged_(*this, "offRoadPositionChanged", "ui", std::make_tuple(static_cast<CommonAPI::EmptyDeployment*>(nullptr), static_cast<CommonAPI::EmptyDeployment*>(nullptr)))
{
}


MapMatchedPositionDBusProxy::SimulationStatusChangedEvent& MapMatchedPositionDBusProxy::getSimulationStatusChangedEvent() {
    return simulationStatusChanged_;
}
MapMatchedPositionDBusProxy::SimulationSpeedChangedEvent& MapMatchedPositionDBusProxy::getSimulationSpeedChangedEvent() {
    return simulationSpeedChanged_;
}
MapMatchedPositionDBusProxy::PositionUpdateEvent& MapMatchedPositionDBusProxy::getPositionUpdateEvent() {
    return positionUpdate_;
}
MapMatchedPositionDBusProxy::AddressUpdateEvent& MapMatchedPositionDBusProxy::getAddressUpdateEvent() {
    return addressUpdate_;
}
MapMatchedPositionDBusProxy::PositionOnSegmentUpdateEvent& MapMatchedPositionDBusProxy::getPositionOnSegmentUpdateEvent() {
    return positionOnSegmentUpdate_;
}
MapMatchedPositionDBusProxy::StatusUpdateEvent& MapMatchedPositionDBusProxy::getStatusUpdateEvent() {
    return statusUpdate_;
}
MapMatchedPositionDBusProxy::OffRoadPositionChangedEvent& MapMatchedPositionDBusProxy::getOffRoadPositionChangedEvent() {
    return offRoadPositionChanged_;
}
    
    /**
     * description: getVersion = This method returns the API version implemented by the server
     *   application
     */
    void MapMatchedPositionDBusProxy::getVersion(CommonAPI::CallStatus &_internalCallStatus, ::v4::org::genivi::CommonTypes::Version &_version, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::CommonTypes::Version, ::v4::org::genivi::CommonTypes_::VersionDeployment_t> deploy_version(static_cast<::v4::org::genivi::CommonTypes_::VersionDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::CommonTypes::Version,::v4::org::genivi::CommonTypes_::VersionDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getVersion",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_version);
_version = deploy_version.getValue();
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::getVersionAsync(GetVersionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::CommonTypes::Version, ::v4::org::genivi::CommonTypes_::VersionDeployment_t> deploy_version(static_cast<::v4::org::genivi::CommonTypes_::VersionDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::CommonTypes::Version,::v4::org::genivi::CommonTypes_::VersionDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getVersion",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<::v4::org::genivi::CommonTypes::Version, ::v4::org::genivi::CommonTypes_::VersionDeployment_t> _version) {
        	if (_callback)
        		_callback(_internalCallStatus, _version.getValue());
        },
        std::make_tuple(deploy_version));
    }
    /**
     * description: setSimulationMode = This method activates or deactivates the simulation mode
     */
    void MapMatchedPositionDBusProxy::setSimulationMode(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const bool &_activate, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_activate(_activate, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "setSimulationMode",
        "ub",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_activate,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::setSimulationModeAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const bool &_activate, SetSimulationModeAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment> deploy_activate(_activate, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<bool, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "setSimulationMode",
        "ub",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_activate,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: getSimulationStatus = This method retrieves the simulation status
     */
    void MapMatchedPositionDBusProxy::getSimulationStatus(CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::SimulationStatus &_simulationStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<MapMatchedPosition::SimulationStatus, CommonAPI::EmptyDeployment> deploy_simulationStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<MapMatchedPosition::SimulationStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getSimulationStatus",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_simulationStatus);
_simulationStatus = deploy_simulationStatus.getValue();
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::getSimulationStatusAsync(GetSimulationStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<MapMatchedPosition::SimulationStatus, CommonAPI::EmptyDeployment> deploy_simulationStatus(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<MapMatchedPosition::SimulationStatus,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getSimulationStatus",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<MapMatchedPosition::SimulationStatus, CommonAPI::EmptyDeployment> _simulationStatus) {
        	if (_callback)
        		_callback(_internalCallStatus, _simulationStatus.getValue());
        },
        std::make_tuple(deploy_simulationStatus));
    }
    /**
     * description: AddSimulationStatusListener = Add this node as a listener to Simulation Status
     *   changes.
     */
    void MapMatchedPositionDBusProxy::addSimulationStatusListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "addSimulationStatusListener",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::addSimulationStatusListenerAsync(AddSimulationStatusListenerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "addSimulationStatusListener",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: RemoveSimulationStatusListener = Remove this node as a listener to Simulation
     *   Status changes.
     */
    void MapMatchedPositionDBusProxy::removeSimulationStatusListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "removeSimulationStatusListener",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::removeSimulationStatusListenerAsync(RemoveSimulationStatusListenerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "removeSimulationStatusListener",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: setSimulationSpeed = This method sets the speed factor for the simulation mode
     */
    void MapMatchedPositionDBusProxy::setSimulationSpeed(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const uint8_t &_speedFactor, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_speedFactor(_speedFactor, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "setSimulationSpeed",
        "uy",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_speedFactor,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::setSimulationSpeedAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const uint8_t &_speedFactor, SetSimulationSpeedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_speedFactor(_speedFactor, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "setSimulationSpeed",
        "uy",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_speedFactor,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: getSimulationSpeed = returns the speed factor for the simulation mode
     */
    void MapMatchedPositionDBusProxy::getSimulationSpeed(CommonAPI::CallStatus &_internalCallStatus, uint8_t &_speedFactor, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_speedFactor(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodWithReply(
        *this,
        "getSimulationSpeed",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus,
deploy_speedFactor);
_speedFactor = deploy_speedFactor.getValue();
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::getSimulationSpeedAsync(GetSimulationSpeedAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> deploy_speedFactor(static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<uint8_t,CommonAPI::EmptyDeployment>
            >
        	>::callMethodAsync(
        *this,
        "getSimulationSpeed",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<uint8_t, CommonAPI::EmptyDeployment> _speedFactor) {
        	if (_callback)
        		_callback(_internalCallStatus, _speedFactor.getValue());
        },
        std::make_tuple(deploy_speedFactor));
    }
    /**
     * description: AddSimulationSpeedListener = Add this node as a listener to simulation speed
     *   factor changes.
     */
    void MapMatchedPositionDBusProxy::addSimulationSpeedListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "addSimulationSpeedListener",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::addSimulationSpeedListenerAsync(AddSimulationSpeedListenerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "addSimulationSpeedListener",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: RemoveSimulationSpeedListener = Remove this node as a listener to simulation
     *   speed factor changes.
     */
    void MapMatchedPositionDBusProxy::removeSimulationSpeedListener(CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "removeSimulationSpeedListener",
        "",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::removeSimulationSpeedListenerAsync(RemoveSimulationSpeedListenerAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "removeSimulationSpeedListener",
        "",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: startSimulation = This method starts, or resumes, a Follow Active Route
     *   simulation
     */
    void MapMatchedPositionDBusProxy::startSimulation(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "startSimulation",
        "u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::startSimulationAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, StartSimulationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "startSimulation",
        "u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: pauseSimulation = This method freezes the current location
     */
    void MapMatchedPositionDBusProxy::pauseSimulation(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "pauseSimulation",
        "u",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::pauseSimulationAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, PauseSimulationAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "pauseSimulation",
        "u",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: getPosition = This method returns the current position
     */
    void MapMatchedPositionDBusProxy::getPosition(const std::vector<MapMatchedPosition::PositionItemKey> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::PositionItemDict &_position, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionItemKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<MapMatchedPosition::PositionItemDict, MapMatchedPosition_::PositionItemDictDeployment_t> deploy_position(static_cast<MapMatchedPosition_::PositionItemDictDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionItemKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<MapMatchedPosition::PositionItemDict,MapMatchedPosition_::PositionItemDictDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getPosition",
        "ai",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_valuesToReturn,
_internalCallStatus,
deploy_position);
_position = deploy_position.getValue();
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::getPositionAsync(const std::vector<MapMatchedPosition::PositionItemKey> &_valuesToReturn, GetPositionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionItemKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<MapMatchedPosition::PositionItemDict, MapMatchedPosition_::PositionItemDictDeployment_t> deploy_position(static_cast<MapMatchedPosition_::PositionItemDictDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionItemKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<MapMatchedPosition::PositionItemDict,MapMatchedPosition_::PositionItemDictDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getPosition",
        "ai",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_valuesToReturn,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<MapMatchedPosition::PositionItemDict, MapMatchedPosition_::PositionItemDictDeployment_t> _position) {
        	if (_callback)
        		_callback(_internalCallStatus, _position.getValue());
        },
        std::make_tuple(deploy_position));
    }
    /**
     * description: setPosition = This method sets the position to a specific location
     */
    void MapMatchedPositionDBusProxy::setPosition(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const MapMatchedPosition::PositionItemDict &_position, CommonAPI::CallStatus &_internalCallStatus, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<MapMatchedPosition::PositionItemDict, MapMatchedPosition_::PositionItemDictDeployment_t> deploy_position(_position, static_cast<MapMatchedPosition_::PositionItemDictDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<MapMatchedPosition::PositionItemDict, MapMatchedPosition_::PositionItemDictDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodWithReply(
        *this,
        "setPosition",
        "ua{i(yv)}",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_sessionHandle, deploy_position,
_internalCallStatus);
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::setPositionAsync(const ::v4::org::genivi::navigation::NavigationTypes::Handle &_sessionHandle, const MapMatchedPosition::PositionItemDict &_position, SetPositionAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment> deploy_sessionHandle(_sessionHandle, static_cast<CommonAPI::EmptyDeployment*>(nullptr));
        CommonAPI::Deployable<MapMatchedPosition::PositionItemDict, MapMatchedPosition_::PositionItemDictDeployment_t> deploy_position(_position, static_cast<MapMatchedPosition_::PositionItemDictDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<::v4::org::genivi::navigation::NavigationTypes::Handle, CommonAPI::EmptyDeployment >,
            CommonAPI::Deployable<MapMatchedPosition::PositionItemDict, MapMatchedPosition_::PositionItemDictDeployment_t >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            >
        	>::callMethodAsync(
        *this,
        "setPosition",
        "ua{i(yv)}",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_sessionHandle, deploy_position,
        [_callback] (CommonAPI::CallStatus _internalCallStatus) {
        	if (_callback)
        		_callback(_internalCallStatus);
        },
        std::make_tuple());
    }
    /**
     * description: getAddress = This method returns the current address
     */
    void MapMatchedPositionDBusProxy::getCurrentAddress(const std::vector<MapMatchedPosition::AddressItemKey> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::AddressItemDict &_address, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<MapMatchedPosition::AddressItemKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<MapMatchedPosition::AddressItemDict, MapMatchedPosition_::AddressItemDictDeployment_t> deploy_address(static_cast<MapMatchedPosition_::AddressItemDictDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<MapMatchedPosition::AddressItemKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<MapMatchedPosition::AddressItemDict,MapMatchedPosition_::AddressItemDictDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getCurrentAddress",
        "ai",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_valuesToReturn,
_internalCallStatus,
deploy_address);
_address = deploy_address.getValue();
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::getCurrentAddressAsync(const std::vector<MapMatchedPosition::AddressItemKey> &_valuesToReturn, GetCurrentAddressAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<MapMatchedPosition::AddressItemKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<MapMatchedPosition::AddressItemDict, MapMatchedPosition_::AddressItemDictDeployment_t> deploy_address(static_cast<MapMatchedPosition_::AddressItemDictDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<MapMatchedPosition::AddressItemKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<MapMatchedPosition::AddressItemDict,MapMatchedPosition_::AddressItemDictDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getCurrentAddress",
        "ai",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_valuesToReturn,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<MapMatchedPosition::AddressItemDict, MapMatchedPosition_::AddressItemDictDeployment_t> _address) {
        	if (_callback)
        		_callback(_internalCallStatus, _address.getValue());
        },
        std::make_tuple(deploy_address));
    }
    /**
     * description: positionOnSegment = This method returns the vehicle position on a route segment
     */
    void MapMatchedPositionDBusProxy::getPositionOnSegment(const std::vector<MapMatchedPosition::PositionOnSegmentKey> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::PositionOnSegmentDict &_positionOnSegment, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionOnSegmentKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<MapMatchedPosition::PositionOnSegmentDict, MapMatchedPosition_::PositionOnSegmentDictDeployment_t> deploy_positionOnSegment(static_cast<MapMatchedPosition_::PositionOnSegmentDictDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionOnSegmentKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<MapMatchedPosition::PositionOnSegmentDict,MapMatchedPosition_::PositionOnSegmentDictDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getPositionOnSegment",
        "ai",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_valuesToReturn,
_internalCallStatus,
deploy_positionOnSegment);
_positionOnSegment = deploy_positionOnSegment.getValue();
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::getPositionOnSegmentAsync(const std::vector<MapMatchedPosition::PositionOnSegmentKey> &_valuesToReturn, GetPositionOnSegmentAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionOnSegmentKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<MapMatchedPosition::PositionOnSegmentDict, MapMatchedPosition_::PositionOnSegmentDictDeployment_t> deploy_positionOnSegment(static_cast<MapMatchedPosition_::PositionOnSegmentDictDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionOnSegmentKey>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<MapMatchedPosition::PositionOnSegmentDict,MapMatchedPosition_::PositionOnSegmentDictDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getPositionOnSegment",
        "ai",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_valuesToReturn,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<MapMatchedPosition::PositionOnSegmentDict, MapMatchedPosition_::PositionOnSegmentDictDeployment_t> _positionOnSegment) {
        	if (_callback)
        		_callback(_internalCallStatus, _positionOnSegment.getValue());
        },
        std::make_tuple(deploy_positionOnSegment));
    }
    /**
     * description: getStatus = This method returns the current status
     */
    void MapMatchedPositionDBusProxy::getStatus(const std::vector<MapMatchedPosition::PositionStatus> &_valuesToReturn, CommonAPI::CallStatus &_internalCallStatus, MapMatchedPosition::PositionStatusDict &_status, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionStatus>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<MapMatchedPosition::PositionStatusDict, MapMatchedPosition_::PositionStatusDictDeployment_t> deploy_status(static_cast<MapMatchedPosition_::PositionStatusDictDeployment_t*>(nullptr));
        CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionStatus>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<MapMatchedPosition::PositionStatusDict,MapMatchedPosition_::PositionStatusDictDeployment_t>
            >
        	>::callMethodWithReply(
        *this,
        "getStatus",
        "ai",
(_info ? _info : &CommonAPI::DBus::defaultCallInfo),
deploy_valuesToReturn,
_internalCallStatus,
deploy_status);
_status = deploy_status.getValue();
}
    std::future<CommonAPI::CallStatus> MapMatchedPositionDBusProxy::getStatusAsync(const std::vector<MapMatchedPosition::PositionStatus> &_valuesToReturn, GetStatusAsyncCallback _callback, const CommonAPI::CallInfo *_info) {
        CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionStatus>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>> deploy_valuesToReturn(_valuesToReturn, static_cast<CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment>*>(nullptr));
        CommonAPI::Deployable<MapMatchedPosition::PositionStatusDict, MapMatchedPosition_::PositionStatusDictDeployment_t> deploy_status(static_cast<MapMatchedPosition_::PositionStatusDictDeployment_t*>(nullptr));
        return CommonAPI::DBus::DBusProxyHelper<
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<std::vector<MapMatchedPosition::PositionStatus>, CommonAPI::DBus::ArrayDeployment<CommonAPI::EmptyDeployment> >
            >,
            CommonAPI::DBus::DBusSerializableArguments<
            CommonAPI::Deployable<MapMatchedPosition::PositionStatusDict,MapMatchedPosition_::PositionStatusDictDeployment_t>
            >
        	>::callMethodAsync(
        *this,
        "getStatus",
        "ai",
        (_info ? _info : &CommonAPI::DBus::defaultCallInfo),
        deploy_valuesToReturn,
        [_callback] (CommonAPI::CallStatus _internalCallStatus, CommonAPI::Deployable<MapMatchedPosition::PositionStatusDict, MapMatchedPosition_::PositionStatusDictDeployment_t> _status) {
        	if (_callback)
        		_callback(_internalCallStatus, _status.getValue());
        },
        std::make_tuple(deploy_status));
    }


void MapMatchedPositionDBusProxy::getOwnVersion(uint16_t& ownVersionMajor, uint16_t& ownVersionMinor) const {
          ownVersionMajor = 4;
          ownVersionMinor = 0;
      }

      } // namespace navigationcore
      } // namespace navigation
      } // namespace genivi
      } // namespace org
      } // namespace v4
