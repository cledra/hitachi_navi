/*
* This file was generated by the CommonAPI Generators.
* Used org.genivi.commonapi.core 3.1.5.v201608040617.
* Used org.franca.core 0.9.1.201412191134.
*
* This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0.
* If a copy of the MPL was not distributed with this file, You can obtain one at
* http://mozilla.org/MPL/2.0/.
*/
/**
 * description: This interface allows a user to find locations by entering a single text
 *   string.
A user of a navigation system needs to find a location on a map, e.g.
 *   to use as a destination of a route.
Locations can be identified by different
 *   means, for example:
 - An address, e.g. '2400 Camino Ramon, San Ramon,
 *   California, USA.'
 - A point of interest, e.g. 'Eiffel Tower'.
 - A named
 *   place, .e.g. 'Amsterdam'

This interface allows a user to find these locations
 *   by entering a single text string.
The system will respond with locations that
 *   match the given text string.
For each location, a location handle will be
 *   returned that can be used as input to other interfaces,
for example to plan a
 *   route, or to get more attributes of a point of interest.
A free text search is
 *   initiated by sending a free text search request (Method FtsRequest) containing
 *   the search text and search options input by the user.
Depending on search
 *   options both addresses and POIs are searched for matches. A single request may
 *   get multiple result responses (via Signals):
 - FtsResultAddresses to report
 *   address matches
 - FtsResultPois to report POI matches
 -
 *   FtsResultPoiSuggestions to give suggestions for doing specific POI
 *   queries
Each response comes as soon as the results are available, so address
 *   results may be received while the search process continues looking for POI
 *   matches.
The order in which the results will be received is not defined. The
 *   search engine determines which results to return first based on the user
 *   input.
If there are no matches found in a certain type of result, then no
 *   response for that type will be sent.
E.g. if the user input only matches an
 *   address but not POIs, then no FtsResultPois response will be sent.
To indicate
 *   that the search has finished an FtsDone signal is sent.
 */
#ifndef V4_ORG_GENIVI_NAVIGATION_FREETEXTSEARCHSERVICE_FREE_TEXT_SEARCH_HPP_
#define V4_ORG_GENIVI_NAVIGATION_FREETEXTSEARCHSERVICE_FREE_TEXT_SEARCH_HPP_


#include <v4/org/genivi/navigation/NavigationTypes.hpp>


#if !defined (COMMONAPI_INTERNAL_COMPILATION)
#define COMMONAPI_INTERNAL_COMPILATION
#endif

#include <CommonAPI/Deployment.hpp>
#include <CommonAPI/InputStream.hpp>
#include <CommonAPI/OutputStream.hpp>
#include <CommonAPI/Struct.hpp>
#include <CommonAPI/Types.hpp>
#include <CommonAPI/Variant.hpp>
#include <cstdint>
#include <memory>
#include <string>
#include <vector>

#undef COMMONAPI_INTERNAL_COMPILATION

namespace v4 {
namespace org {
namespace genivi {
namespace navigation {
namespace freetextsearchservice {

class FreeTextSearch {
public:
    virtual ~FreeTextSearch() { }

    static inline const char* getInterface();
    static inline CommonAPI::Version getInterfaceVersion();
    /**
     * description: A requestId is an identifier used to match a response to a request.
           
     *   Range[0x1:0x7fff]
            notSpecifiedValue = 0x0
     */
    typedef int16_t RequestId;
    /**
     * description: Handle for a single Free Text Search session.
     */
    typedef ::v4::org::genivi::navigation::NavigationTypes::Handle FreeTextSearchHandle;
    /**
     * description: Type to represent most texts in this interface..
            Character set =
     *   UNICODE
            Maximum length = 4095
     */
    typedef std::string FtsString;
    /**
     * description: A list of strings
            maximum length = 100
     */
    typedef std::vector<FreeTextSearch::FtsString> FtsStringList;
    /**
     * description: A union to contain any of the possble search shapes.
     */
    typedef CommonAPI::Variant<::v4::org::genivi::navigation::NavigationTypes::Circle, ::v4::org::genivi::navigation::NavigationTypes::Rectangle>  Shape;
    /**
     * description: A list of shapes.
            maximum length = 31
     */
    typedef std::vector<FreeTextSearch::Shape> ShapeList;
    /**
     * description: A maximum number of results to be returned.
            Range[0:1000]
     */
    typedef uint16_t PageSize;
    
    struct SearchOption : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            ADDRESS = 1,
            POI = 2,
            POI_SUGGESTION = 4,
            NO_PLACES = 65536,
            NO_STREETS = 131072,
            NO_POI_CATEGORY_ASSUMPTIONS = 262144
        };
        
        SearchOption() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::ADDRESS)) {}
        SearchOption(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::ADDRESS):
                case static_cast<int32_t>(Literal::POI):
                case static_cast<int32_t>(Literal::POI_SUGGESTION):
                case static_cast<int32_t>(Literal::NO_PLACES):
                case static_cast<int32_t>(Literal::NO_STREETS):
                case static_cast<int32_t>(Literal::NO_POI_CATEGORY_ASSUMPTIONS):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const SearchOption &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const SearchOption &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const SearchOption &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const SearchOption &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const SearchOption &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const SearchOption &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: An OR-ed combination of SearchOption flags.
            Range[0:0xffffffff]
     */
    typedef uint32_t SearchOptions;
    
    struct FtsStatus : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            OK = 0,
            ABORTED = 1,
            PREFIX_TOO_SHORT = 2,
            INTERNAL_ERROR = 3,
            INDEX_MISSING = 4,
            BAD_VERSION = 5,
            INVALID_PARAMETER_SEARCH_HANDLE = 6,
            INVALID_PARAMETER_QUERY = 7,
            INVALID_PARAMETER_SEARCH_LOCATION = 8,
            INVALID_PARAMETER_PAGE_SIZE = 9,
            INVALID_PARAMETER_SEARCH_OPTIONS = 10,
            INVALID_PARAMETER_SEARCH_CONDITIONS = 11,
            INVALID_PARAMETER_SEARCH_SHAPES = 12
        };
        
        FtsStatus() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::OK)) {}
        FtsStatus(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::OK):
                case static_cast<int32_t>(Literal::ABORTED):
                case static_cast<int32_t>(Literal::PREFIX_TOO_SHORT):
                case static_cast<int32_t>(Literal::INTERNAL_ERROR):
                case static_cast<int32_t>(Literal::INDEX_MISSING):
                case static_cast<int32_t>(Literal::BAD_VERSION):
                case static_cast<int32_t>(Literal::INVALID_PARAMETER_SEARCH_HANDLE):
                case static_cast<int32_t>(Literal::INVALID_PARAMETER_QUERY):
                case static_cast<int32_t>(Literal::INVALID_PARAMETER_SEARCH_LOCATION):
                case static_cast<int32_t>(Literal::INVALID_PARAMETER_PAGE_SIZE):
                case static_cast<int32_t>(Literal::INVALID_PARAMETER_SEARCH_OPTIONS):
                case static_cast<int32_t>(Literal::INVALID_PARAMETER_SEARCH_CONDITIONS):
                case static_cast<int32_t>(Literal::INVALID_PARAMETER_SEARCH_SHAPES):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const FtsStatus &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const FtsStatus &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const FtsStatus &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const FtsStatus &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const FtsStatus &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const FtsStatus &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Handle to a location.
            Range[0:0xffffffff]
     */
    typedef uint32_t LocationHandle;
    /**
     * description: A list of LocationHandles.
            maximum length = 4096
     */
    typedef std::vector<::v4::org::genivi::navigation::NavigationTypes::LocationHandle> LocationHandleList;
    /**
     * description: If a user entered a non-existing house number then the closest existing
    	   
     *   number is returned. The houseNumberFromInput will contain the house
    	   
     *   number from the user input, the houseNumber will contain closest house
     *   number.
    	    If the map does not contain house numbers for the street, but the
     *   user
    	    input seems to have a house number, then houseNumber will be empty
     *   and
    	    houseNumberFromInput will contain the number from the input.
     */
    struct StreetDetails : CommonAPI::Struct<FtsString, FtsString, FtsString> {
    	
    	StreetDetails() {
    	}
    	StreetDetails(const FtsString &_streetName, const FtsString &_houseNumber, const FtsString &_houseNumberFromInput)
    	{
    		std::get<0>(values_) = _streetName;
    		std::get<1>(values_) = _houseNumber;
    		std::get<2>(values_) = _houseNumberFromInput;
    	}
    	inline const FtsString &getStreetName() const { return std::get<0>(values_); }
    	inline void setStreetName(const FtsString &_value) { std::get<0>(values_) = _value; }
    	/**
    	 * description: If a user entered a non-existing house number then the closest existing
    		      
    	 *    number is returned. The houseNumberFromInput will contain the house
    		       
    	 *   number from the user input, the houseNumber will contain closest house
    	 *   number.
    		        If the map does not contain house numbers for the street, but
    	 *   the user
    		        input seems to have a house number, then houseNumber will be
    	 *   empty and
    	    	    houseNumberFromInput will contain the number from the input.
    	 */
    	inline const FtsString &getHouseNumber() const { return std::get<1>(values_); }
    	inline void setHouseNumber(const FtsString &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The house number that the search engine recognized in the user input.
    		       
    	 *   Can be empty.
    	 */
    	inline const FtsString &getHouseNumberFromInput() const { return std::get<2>(values_); }
    	inline void setHouseNumberFromInput(const FtsString &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const StreetDetails& _other) const {
                return (getStreetName() == _other.getStreetName() && getHouseNumber() == _other.getHouseNumber() && getHouseNumberFromInput() == _other.getHouseNumberFromInput());
        }
    	inline bool operator!=(const StreetDetails &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    
    struct PlaceType : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            OTHER = 0,
            SETTLEMENT = 2
        };
        
        PlaceType() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::OTHER)) {}
        PlaceType(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::OTHER):
                case static_cast<int32_t>(Literal::SETTLEMENT):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const PlaceType &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const PlaceType &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const PlaceType &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const PlaceType &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const PlaceType &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const PlaceType &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
    /**
     * description: Place details.
     */
    struct PlaceDetails : CommonAPI::Struct<PlaceType, FtsString, ::v4::org::genivi::navigation::NavigationTypes::Rectangle> {
    	
    	PlaceDetails() {
    	}
    	PlaceDetails(const PlaceType &_placeType, const FtsString &_placeName, const ::v4::org::genivi::navigation::NavigationTypes::Rectangle &_placeBoundingBox)
    	{
    		std::get<0>(values_) = _placeType;
    		std::get<1>(values_) = _placeName;
    		std::get<2>(values_) = _placeBoundingBox;
    	}
    	inline const PlaceType &getPlaceType() const { return std::get<0>(values_); }
    	inline void setPlaceType(const PlaceType &_value) { std::get<0>(values_) = _value; }
    	inline const FtsString &getPlaceName() const { return std::get<1>(values_); }
    	inline void setPlaceName(const FtsString &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The bounding box of this place (an estimate).
    	 */
    	inline const ::v4::org::genivi::navigation::NavigationTypes::Rectangle &getPlaceBoundingBox() const { return std::get<2>(values_); }
    	inline void setPlaceBoundingBox(const ::v4::org::genivi::navigation::NavigationTypes::Rectangle &_value) { std::get<2>(values_) = _value; }
    	inline bool operator==(const PlaceDetails& _other) const {
                return (getPlaceType() == _other.getPlaceType() && getPlaceName() == _other.getPlaceName() && getPlaceBoundingBox() == _other.getPlaceBoundingBox());
        }
    	inline bool operator!=(const PlaceDetails &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: Mapcode details.
     */
    struct MapCodeDetails : CommonAPI::Struct<FtsString> {
    	
    	MapCodeDetails() {
    	}
    	MapCodeDetails(const FtsString &_closestStreetName)
    	{
    		std::get<0>(values_) = _closestStreetName;
    	}
    	/**
    	 * description: If the location of the mapcode is close to a street, this field
    	    	   
    	 *   contains the name of that street, otherwise this field is left empty.
    	 */
    	inline const FtsString &getClosestStreetName() const { return std::get<0>(values_); }
    	inline void setClosestStreetName(const FtsString &_value) { std::get<0>(values_) = _value; }
    	inline bool operator==(const MapCodeDetails& _other) const {
                return (getClosestStreetName() == _other.getClosestStreetName());
        }
    	inline bool operator!=(const MapCodeDetails &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: A union to contain any of the specific types of address details.
     */
    typedef CommonAPI::Variant<StreetDetails, PlaceDetails, MapCodeDetails>  AddressDetails;
    /**
     * description: A higher score means a better match.
            Range[0:0xffff]
     */
    typedef uint16_t Score;
    /**
     * description: Address information.
     */
    struct Address : CommonAPI::Struct<::v4::org::genivi::navigation::NavigationTypes::LocationHandle, FtsString, FtsString, FtsStringList, FtsStringList, FtsString, AddressDetails, ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D, ::v4::org::genivi::navigation::NavigationTypes::DistanceInMeters, Score, bool> {
    	
    	Address() {
    		std::get<10>(values_) = false;
    	}
    	Address(const ::v4::org::genivi::navigation::NavigationTypes::LocationHandle &_locationHandle, const FtsString &_countryCode, const FtsString &_stateCode, const FtsStringList &_places, const FtsStringList &_postalCodes, const FtsString &_mapCode, const AddressDetails &_addressDetails, const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &_coordinate, const ::v4::org::genivi::navigation::NavigationTypes::DistanceInMeters &_distance, const Score &_score, const bool &_fuzzyMatch)
    	{
    		std::get<0>(values_) = _locationHandle;
    		std::get<1>(values_) = _countryCode;
    		std::get<2>(values_) = _stateCode;
    		std::get<3>(values_) = _places;
    		std::get<4>(values_) = _postalCodes;
    		std::get<5>(values_) = _mapCode;
    		std::get<6>(values_) = _addressDetails;
    		std::get<7>(values_) = _coordinate;
    		std::get<8>(values_) = _distance;
    		std::get<9>(values_) = _score;
    		std::get<10>(values_) = _fuzzyMatch;
    	}
    	inline const ::v4::org::genivi::navigation::NavigationTypes::LocationHandle &getLocationHandle() const { return std::get<0>(values_); }
    	inline void setLocationHandle(const ::v4::org::genivi::navigation::NavigationTypes::LocationHandle &_value) { std::get<0>(values_) = _value; }
    	inline const FtsString &getCountryCode() const { return std::get<1>(values_); }
    	inline void setCountryCode(const FtsString &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: Optional state code.
    	 */
    	inline const FtsString &getStateCode() const { return std::get<2>(values_); }
    	inline void setStateCode(const FtsString &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: There can be multiple place names.
    	 */
    	inline const FtsStringList &getPlaces() const { return std::get<3>(values_); }
    	inline void setPlaces(const FtsStringList &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: There can be multiple postal codes assigned to a street.
    	 */
    	inline const FtsStringList &getPostalCodes() const { return std::get<4>(values_); }
    	inline void setPostalCodes(const FtsStringList &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: Mapcode of the coordinate.
    	    	    A mapcode represents a location. Every
    	 *   location on Earth can be represented by a mapcode.
    	    	    Mapcodes were
    	 *   designed to be short, easy to recognize, remember and communicate.
    	    	   
    	 *   They are precise to a few meters. For details see http://www.mapcode.com.
    	 */
    	inline const FtsString &getMapCode() const { return std::get<5>(values_); }
    	inline void setMapCode(const FtsString &_value) { std::get<5>(values_) = _value; }
    	inline const AddressDetails &getAddressDetails() const { return std::get<6>(values_); }
    	inline void setAddressDetails(const AddressDetails &_value) { std::get<6>(values_) = _value; }
    	inline const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &getCoordinate() const { return std::get<7>(values_); }
    	inline void setCoordinate(const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &_value) { std::get<7>(values_) = _value; }
    	/**
    	 * description: Distance in meters from the search location.
    	    	    -1 if no search location
    	 *   is given.
    	 */
    	inline const ::v4::org::genivi::navigation::NavigationTypes::DistanceInMeters &getDistance() const { return std::get<8>(values_); }
    	inline void setDistance(const ::v4::org::genivi::navigation::NavigationTypes::DistanceInMeters &_value) { std::get<8>(values_) = _value; }
    	/**
    	 * description: A higher score means a better match.
    	 */
    	inline const Score &getScore() const { return std::get<9>(values_); }
    	inline void setScore(const Score &_value) { std::get<9>(values_) = _value; }
    	/**
    	 * description: Indicates whether this match is fuzzy, i.e. it was matched with misspellings.
    	 */
    	inline const bool &getFuzzyMatch() const { return std::get<10>(values_); }
    	inline void setFuzzyMatch(const bool _value) { std::get<10>(values_) = _value; }
    	inline bool operator==(const Address& _other) const {
                return (getLocationHandle() == _other.getLocationHandle() && getCountryCode() == _other.getCountryCode() && getStateCode() == _other.getStateCode() && getPlaces() == _other.getPlaces() && getPostalCodes() == _other.getPostalCodes() && getMapCode() == _other.getMapCode() && getAddressDetails() == _other.getAddressDetails() && getCoordinate() == _other.getCoordinate() && getDistance() == _other.getDistance() && getScore() == _other.getScore() && getFuzzyMatch() == _other.getFuzzyMatch());
        }
    	inline bool operator!=(const Address &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: A list of addresses.
            maximum length = 500
     */
    typedef std::vector<FreeTextSearch::Address> Addresses;
    /**
     * description: Numerical POI category code.
            Range[0:0xffffffff]
     */
    typedef uint32_t POICategoryCode;
    /**
     * description: POI information.
     */
    struct POI : CommonAPI::Struct<::v4::org::genivi::navigation::NavigationTypes::LocationHandle, POICategoryCode, FtsStringList, FtsString, FtsString, FtsStringList, FtsStringList, FtsString, FtsString, FtsString, FtsString, ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D, ::v4::org::genivi::navigation::NavigationTypes::DistanceInMeters, Score, bool> {
    	
    	POI() {
    		std::get<14>(values_) = false;
    	}
    	POI(const ::v4::org::genivi::navigation::NavigationTypes::LocationHandle &_locationHandle, const POICategoryCode &_categoryCode, const FtsStringList &_brandNames, const FtsString &_poiName, const FtsString &_address, const FtsStringList &_place, const FtsStringList &_postalCode, const FtsString &_mapCode, const FtsString &_countryCode, const FtsString &_stateCode, const FtsString &_telephone, const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &_coordinate, const ::v4::org::genivi::navigation::NavigationTypes::DistanceInMeters &_distance, const Score &_score, const bool &_fuzzyMatch)
    	{
    		std::get<0>(values_) = _locationHandle;
    		std::get<1>(values_) = _categoryCode;
    		std::get<2>(values_) = _brandNames;
    		std::get<3>(values_) = _poiName;
    		std::get<4>(values_) = _address;
    		std::get<5>(values_) = _place;
    		std::get<6>(values_) = _postalCode;
    		std::get<7>(values_) = _mapCode;
    		std::get<8>(values_) = _countryCode;
    		std::get<9>(values_) = _stateCode;
    		std::get<10>(values_) = _telephone;
    		std::get<11>(values_) = _coordinate;
    		std::get<12>(values_) = _distance;
    		std::get<13>(values_) = _score;
    		std::get<14>(values_) = _fuzzyMatch;
    	}
    	inline const ::v4::org::genivi::navigation::NavigationTypes::LocationHandle &getLocationHandle() const { return std::get<0>(values_); }
    	inline void setLocationHandle(const ::v4::org::genivi::navigation::NavigationTypes::LocationHandle &_value) { std::get<0>(values_) = _value; }
    	inline const POICategoryCode &getCategoryCode() const { return std::get<1>(values_); }
    	inline void setCategoryCode(const POICategoryCode &_value) { std::get<1>(values_) = _value; }
    	inline const FtsStringList &getBrandNames() const { return std::get<2>(values_); }
    	inline void setBrandNames(const FtsStringList &_value) { std::get<2>(values_) = _value; }
    	inline const FtsString &getPoiName() const { return std::get<3>(values_); }
    	inline void setPoiName(const FtsString &_value) { std::get<3>(values_) = _value; }
    	inline const FtsString &getAddress() const { return std::get<4>(values_); }
    	inline void setAddress(const FtsString &_value) { std::get<4>(values_) = _value; }
    	inline const FtsStringList &getPlace() const { return std::get<5>(values_); }
    	inline void setPlace(const FtsStringList &_value) { std::get<5>(values_) = _value; }
    	inline const FtsStringList &getPostalCode() const { return std::get<6>(values_); }
    	inline void setPostalCode(const FtsStringList &_value) { std::get<6>(values_) = _value; }
    	inline const FtsString &getMapCode() const { return std::get<7>(values_); }
    	inline void setMapCode(const FtsString &_value) { std::get<7>(values_) = _value; }
    	inline const FtsString &getCountryCode() const { return std::get<8>(values_); }
    	inline void setCountryCode(const FtsString &_value) { std::get<8>(values_) = _value; }
    	inline const FtsString &getStateCode() const { return std::get<9>(values_); }
    	inline void setStateCode(const FtsString &_value) { std::get<9>(values_) = _value; }
    	inline const FtsString &getTelephone() const { return std::get<10>(values_); }
    	inline void setTelephone(const FtsString &_value) { std::get<10>(values_) = _value; }
    	inline const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &getCoordinate() const { return std::get<11>(values_); }
    	inline void setCoordinate(const ::v4::org::genivi::navigation::NavigationTypes::Coordinate2D &_value) { std::get<11>(values_) = _value; }
    	/**
    	 * description: Distance in meters from the search location.
    	    	    -1 if no search location
    	 *   is given.
    	 */
    	inline const ::v4::org::genivi::navigation::NavigationTypes::DistanceInMeters &getDistance() const { return std::get<12>(values_); }
    	inline void setDistance(const ::v4::org::genivi::navigation::NavigationTypes::DistanceInMeters &_value) { std::get<12>(values_) = _value; }
    	/**
    	 * description: A higher score means a better match.
    	 */
    	inline const Score &getScore() const { return std::get<13>(values_); }
    	inline void setScore(const Score &_value) { std::get<13>(values_) = _value; }
    	/**
    	 * description: Indicates whether this match is fuzzy, i.e. it was matched with misspellings.
    	 */
    	inline const bool &getFuzzyMatch() const { return std::get<14>(values_); }
    	inline void setFuzzyMatch(const bool _value) { std::get<14>(values_) = _value; }
    	inline bool operator==(const POI& _other) const {
                return (getLocationHandle() == _other.getLocationHandle() && getCategoryCode() == _other.getCategoryCode() && getBrandNames() == _other.getBrandNames() && getPoiName() == _other.getPoiName() && getAddress() == _other.getAddress() && getPlace() == _other.getPlace() && getPostalCode() == _other.getPostalCode() && getMapCode() == _other.getMapCode() && getCountryCode() == _other.getCountryCode() && getStateCode() == _other.getStateCode() && getTelephone() == _other.getTelephone() && getCoordinate() == _other.getCoordinate() && getDistance() == _other.getDistance() && getScore() == _other.getScore() && getFuzzyMatch() == _other.getFuzzyMatch());
        }
    	inline bool operator!=(const POI &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: A list of POIs.
            maximum length = 500
     */
    typedef std::vector<FreeTextSearch::POI> POIs;
    /**
     * description: Data type for POI category suggestions.
     */
    struct POICategory : CommonAPI::Struct<POICategoryCode, FtsString, FtsString, FtsString, Addresses, Score> {
    	
    	POICategory() {
    	}
    	POICategory(const POICategoryCode &_categoryCode, const FtsString &_categoryName, const FtsString &_matchedName, const FtsString &_searchTextSuggestion, const Addresses &_nearAddressSuggestions, const Score &_score)
    	{
    		std::get<0>(values_) = _categoryCode;
    		std::get<1>(values_) = _categoryName;
    		std::get<2>(values_) = _matchedName;
    		std::get<3>(values_) = _searchTextSuggestion;
    		std::get<4>(values_) = _nearAddressSuggestions;
    		std::get<5>(values_) = _score;
    	}
    	inline const POICategoryCode &getCategoryCode() const { return std::get<0>(values_); }
    	inline void setCategoryCode(const POICategoryCode &_value) { std::get<0>(values_) = _value; }
    	inline const FtsString &getCategoryName() const { return std::get<1>(values_); }
    	inline void setCategoryName(const FtsString &_value) { std::get<1>(values_) = _value; }
    	/**
    	 * description: The search engine recognizes synonyms and names associated with a
    	    	    POI
    	 *   category. If a match on such a name is found, then this attribute is set to
    	 *   that name.
    	 */
    	inline const FtsString &getMatchedName() const { return std::get<2>(values_); }
    	inline void setMatchedName(const FtsString &_value) { std::get<2>(values_) = _value; }
    	/**
    	 * description: Text that can be used for a suggestion like: "<categoryName>
    	 *   <searchTextSuggestion>"
    	    	    Typically this contains the original query
    	 *   text, where the recognized
    	    	    category name or synonym has been removed.
    	 */
    	inline const FtsString &getSearchTextSuggestion() const { return std::get<3>(values_); }
    	inline void setSearchTextSuggestion(const FtsString &_value) { std::get<3>(values_) = _value; }
    	/**
    	 * description: A list of addresses that can be used for suggestions like: "<categoryName> near
    	 *   <address>
    	    	    Note the addresses in this list do not have a valid
    	 *   location handle
    	    	    as the address is only needed to be displayed as a
    	 *   suggestion.
    	    	    The coordinates of an address can be used for a POI
    	 *   window query if the
    	    	    user picks a suggestion.
    	 */
    	inline const Addresses &getNearAddressSuggestions() const { return std::get<4>(values_); }
    	inline void setNearAddressSuggestions(const Addresses &_value) { std::get<4>(values_) = _value; }
    	/**
    	 * description: A higher score means a better match.
    	 */
    	inline const Score &getScore() const { return std::get<5>(values_); }
    	inline void setScore(const Score &_value) { std::get<5>(values_) = _value; }
    	inline bool operator==(const POICategory& _other) const {
                return (getCategoryCode() == _other.getCategoryCode() && getCategoryName() == _other.getCategoryName() && getMatchedName() == _other.getMatchedName() && getSearchTextSuggestion() == _other.getSearchTextSuggestion() && getNearAddressSuggestions() == _other.getNearAddressSuggestions() && getScore() == _other.getScore());
        }
    	inline bool operator!=(const POICategory &_other) const {
    		return !((*this) == _other);
    	}
    
    };
    /**
     * description: A list of POI categories.
            maximum length = 500
     */
    typedef std::vector<FreeTextSearch::POICategory> POICategories;
    /**
     * description: Indicates on a scale from 0 to 5 how fuzzy the search results can be.
            0
     *   means only an exact search is performed, 1 is the lowest level of fuzzy
     *   search
            and 5 means a very fuzzy search.
            Range[0:5]
     */
    typedef int8_t FuzzyLevel;
    /**
     * description: Perform a free text search.
            A single search request will trigger zero
     *   or more FtsResultXxx responses followed by an FtsDone response.
            Each
     *   response will contain 1 page of results.
            A next page of results can be
     *   retrieved with the FtsNextPage request.
            
            When you send a new
     *   request before receiving a done response on the previous request,
            then
     *   the previous request will be canceled.
            You will still get a done
     *   response on the previous request.
            This way each request gets a
     *   response.
     */
    
    struct ftsRequestError : CommonAPI::Enumeration<int32_t> {
        enum Literal : int32_t {
            NoMoreFtsHandles = 0
        };
        
        ftsRequestError() 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(Literal::NoMoreFtsHandles)) {}
        ftsRequestError(Literal _literal) 
            : CommonAPI::Enumeration<int32_t>(static_cast<int32_t>(_literal)) {}
    
        inline bool validate() const {
            switch (value_) {
                case static_cast<int32_t>(Literal::NoMoreFtsHandles):
                return true;
            default:
                return false;
            }
        }
    
        inline bool operator==(const ftsRequestError &_other) const { return (value_ == _other.value_); }
        inline bool operator!=(const ftsRequestError &_other) const { return (value_ != _other.value_); }
        inline bool operator<=(const ftsRequestError &_other) const { return (value_ <= _other.value_); }
        inline bool operator>=(const ftsRequestError &_other) const { return (value_ >= _other.value_); }
        inline bool operator<(const ftsRequestError &_other) const { return (value_ < _other.value_); }
        inline bool operator>(const ftsRequestError &_other) const { return (value_ > _other.value_); }
        
        inline bool operator==(const Literal &_value) const { return (value_ == static_cast<int32_t>(_value)); }
        inline bool operator!=(const Literal &_value) const { return (value_ != static_cast<int32_t>(_value)); }
        inline bool operator<=(const Literal &_value) const { return (value_ <= static_cast<int32_t>(_value)); }
        inline bool operator>=(const Literal &_value) const { return (value_ >= static_cast<int32_t>(_value)); }
        inline bool operator<(const Literal &_value) const { return (value_ < static_cast<int32_t>(_value)); }
        inline bool operator>(const Literal &_value) const { return (value_ > static_cast<int32_t>(_value)); }
    };
};

const char* FreeTextSearch::getInterface() {
    return ("org.genivi.navigation.freetextsearchservice.FreeTextSearch");
}

CommonAPI::Version FreeTextSearch::getInterfaceVersion() {
    return CommonAPI::Version(4, 0);
}

/**
 * description: A requestId is an identifier used to match a response to a request.
       
 *   Range[0x1:0x7fff]
        notSpecifiedValue = 0x0
 */
/**
 * description: Handle for a single Free Text Search session.
 */
/**
 * description: Type to represent most texts in this interface..
        Character set =
 *   UNICODE
        Maximum length = 4095
 */
/**
 * description: A list of strings
        maximum length = 100
 */
/**
 * description: A union to contain any of the possble search shapes.
 */
/**
 * description: A list of shapes.
        maximum length = 31
 */
/**
 * description: A maximum number of results to be returned.
        Range[0:1000]
 */
/**
 * description: Search options for a search request.
        The options are flags which can be
 *   OR-ed together to create SearchOptions.
 */
/**
 * description: An OR-ed combination of SearchOption flags.
        Range[0:0xffffffff]
 */
/**
 * description: Search request status.
 */
/**
 * description: Handle to a location.
        Range[0:0xffffffff]
 */
/**
 * description: A list of LocationHandles.
        maximum length = 4096
 */
/**
 * description: If a user entered a non-existing house number then the closest existing
	   
 *   number is returned. The houseNumberFromInput will contain the house
	   
 *   number from the user input, the houseNumber will contain closest house
 *   number.
	    If the map does not contain house numbers for the street, but the
 *   user
	    input seems to have a house number, then houseNumber will be empty
 *   and
	    houseNumberFromInput will contain the number from the input.
 */
/**
 * description: Place details.
 */
/**
 * description: Mapcode details.
 */
/**
 * description: A union to contain any of the specific types of address details.
 */
/**
 * description: A higher score means a better match.
        Range[0:0xffff]
 */
/**
 * description: Address information.
 */
/**
 * description: A list of addresses.
        maximum length = 500
 */
/**
 * description: Numerical POI category code.
        Range[0:0xffffffff]
 */
/**
 * description: POI information.
 */
/**
 * description: A list of POIs.
        maximum length = 500
 */
/**
 * description: Data type for POI category suggestions.
 */
/**
 * description: A list of POI categories.
        maximum length = 500
 */
/**
 * description: Indicates on a scale from 0 to 5 how fuzzy the search results can be.
        0
 *   means only an exact search is performed, 1 is the lowest level of fuzzy
 *   search
        and 5 means a very fuzzy search.
        Range[0:5]
 */

} // namespace freetextsearchservice
} // namespace navigation
} // namespace genivi
} // namespace org
} // namespace v4

namespace CommonAPI {
}


// Compatibility
namespace v4_0 = v4;

#endif // V4_ORG_GENIVI_NAVIGATION_FREETEXTSEARCHSERVICE_FREE_TEXT_SEARCH_HPP_
